{"./":{"url":"./","title":"简介","keywords":"","body":"Introduction Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-17 09:15:38 "},"centos/centos配置.html":{"url":"centos/centos配置.html","title":"centos配置","keywords":"","body":"模板 [TOC] screen screen root用户可以直接用yum install screen命令安装screen 如果没有root权限，可以采用源码编译安装的方法。 参考：参考博客 相关源码地址： screen：http://ftp.gnu.org/gnu/screen/ ncurses：http://ftp.gnu.org/gnu/ncurses/ 下载screen源码，解压后进入源码目录，执行以下命令安装： ./configure --prefix=/home/username/screen_dir 如果出现如下错误信息： configure: error: !!! no tgetent - no screen 说明缺乏ncurses依赖，下载源码安装： # 进入ncurses源码目录 ./configure --prefix=/home/username/ncurses_dir make make install # 如果第一条命令运行后有Error，可用如下命令尝试替换： # ./configure --refix=/home/username/ncurses_dir --with-shared --without-debug --without-ada --enable-overwrite 之后就可以安装screen了： # 配置相关环境变量 export LDFLAGS='-L/home/username/ncurses_dir/lib' export CPPFLAGS='-I/home/username/ncurses_dir/include' # 安装screen ./configure --prefix='/home/username/screen_dir' make make install 这样就能将screen安装到screen_dir目录下了。接着在.bashrc文件里设置screen执行路径，加入export PATH=/home/username/screen_dir/bin:$PATH，接着执行source .bashrc更新PATH，在终端输入screen就能进入screen界面了。 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-28 21:28:14 "},"centos/linux常用命令.html":{"url":"centos/linux常用命令.html","title":"linux常用命令","keywords":"","body":"linux常用命令 参考：中国大学MOOC，Linux系统管理（国家精品），宁波城市职业技术学院 [TOC] man 开/关机 常用命令 cd mkdir tar gzip locate find chmod ls ll grep cp rm mv su sudo whoami id w xargs 链接 ln 通配符与正则表达式 通配符 正则表达式 重定向 输出重定向 输入重定向 管道 查看机器相关信息 查看文本文件 file cat od less head tail wc tee sort tr uniq sed awk cmp diff md5sum/sha1sum vim 命令行模式 同时编辑多个文件 视窗操作 其他 linux用户，uid 文件系统 硬盘管理 dh 网络配置与管理 netstat 软件包管理 yum 进程 进程操作 ps（process status） top kill 守护进程 systemctl 远程管理 一个完整Linux 操作系统往往由4 部分组成： 内核（Kernel）：内核是Linux 的心脏，实现操作系统的基本功能，包括控制硬件设备、管理内存、提供硬件接口、处理基本I/O、管理文件系统，为程序分配内存和CPU 时间等等。 外壳（Shell）：是Linux 的交流窗口，提供用户与内核进行交互操作的接口。 实用程序(Utilities)：实用程序则是工具，是用户用于进行系统日常操作和管理的一些程序。 应用程序(Applications)：则是给用户提供各种各样的丰富的功能第三方程序，如各种服务器套件、文档处理套件、各种媒体播放和处理套件。 Linux中的命令在正常情况下最少有两个选项，--help和--version。 man 帮助文档相关的命令有好几个，但是 最常用一就帮助文档相关的命令有好几个，但是 最常用一就man 命令， man 就是manual的缩写，用来查看系统中自带各种参考手册。 man name 或 man section name 。 man 命令可以后跟一个数字来表示 要查阅的用户手册 。若不加数字，那 man 命令默认从数字较小的手册中寻找相内容 ： 命令：shell 中可以操作的指令或可执行文件。 系统调用：系统核心可使用的函数与工具等。 库函数：一些常用的函数 (function) 与库 (library) ，大部分为 C的库 (libc)。 设备文件的说明，通常在 /dev 下的文件。 配置文件：配置文件或者是某些文件的格式。 游戏 惯例与协议等，如 Linux 文件系统、 网络协议、ASCII码等等的说明。 系统管理员可用的命令 跟系统核心有关的文件 开/关机 关闭或者重启工作环境下的Linux主机， 正确的做法应该分三步走： 查看在线用户和在线服务 通知用户关机/重启原因和时间安排 下达关机命令 shutdown：关机 shutdown -r：重启系统 常用命令 cd cd： \"~\" 在 Bash中表示当前用户家目录 \".\" 表示当前所在的目录 \"..\" 表示当前所在目录的上一层 ”-” 则表示本次跳转前所处的目录 mkdir mkdir：与之相对的是rmdir。 -p选项允许递归创建目录 -m, --mode=模式， 设置权限模式。mkdir -m 777 xxx创建目录具有777权限。 tar 对多个文件或文件夹进行打包（归档） tar命令是一个古老的命令，其最初目的是用于将文件备份到磁带上，这也是命令名称的来源，tar即“tape archive”，磁带归档，的缩写。 tar [选项] 归档文件列表 操作： -c：创建一个新的归档文件 -r：向归档文件末尾追加文件。tar -f a.tar -r b.c 将b.c添加到a.tar中。 -u：更新归档文件 -x：从归档文件中解压出文件。tar -xf a.tar 将a.tar解包到当前文件夹。 -t：列出归档文件中的文件。tar -tf a.tar列出a.tar中的所有文件 --delete：从归档文件中删除一个文件。tar -f a.tar --delete a.c 删除a.tar中的a.c文件。 -A：合并两个归档文件。tar -f a.tar -A b.tar 将b.tar合并到a.tar中。 选项： -C：指定一个解档目录 -f：指定一个归档文件/设备进行操作。该选项必须紧跟归档文件名！ -z： 调用gzip来压缩/解压缩文件 归档文件的.tar后缀名不是必须的，但是一般我们都会加上这个后缀，以告诉用户这个文件是一个归档文件。 gzip 对文件进行压缩/解压。 gzip [选项] 压缩/解压缩的文件名 压缩：gzip ./a.tar 解压：gzip -d a.tar.gz -c：将输出写到标准输出上，并保留原有文件。 -d：将压缩文件解压。 -r：递归式压缩/解压缩指定目录中的所有文件。 -num：用指定的数字num调整压缩的速度和压缩比。1-9，9为最大压缩比，压缩后的文件最小，但压缩时间长。默认为6。 -v：对每一个压缩和解压的文件显示文件名和压缩比. -t：测试，检查压缩文件是否完整。 注意：gzip 在压缩文件过程中，会自动为文件添加一个“.gz”的后缀名，并且将原文件删除。如果要保留原文件，就必须使用-c 选项和Shell的输出重定向机制。 locate 查找文件：locate 查找路径 文件名的关键字 查找速度很快，但并不是真正到硬盘上去查找文件，而是Linux将系统中所有的文件名都记录在一个名为/var/lib/mlocate/mlocate.db的数据库中，locate查找文件是从该数据库中查找。 因此，locate查找文件有一个重大限制，有时会查找到已经被删除了的数据，或者刚刚建立的文件无法找到。这是由于数据库不实时更新造成的，这个数据库默认情况下每天更新一次。我们也可以通过updatedb命令来手动更新这个数据库。 find 在指定的目录结构中搜索文件，并执行指定的操作。省略目录时在当前目录查找。 find [-print | -ls] [-exec|-ok {} \\;] 找到之后执行的操作： -print：将查找到的文件输出到标准输出。find命令的默认动作，将查找到的文件名输出 -fprint ： 将查找到的文件输出到指定文件 -ls：将将查找到的文件名以ls –dils格式输出 -exec command {} \\;：将查到的文件执行command操作，{} 和\\;之间有空格。用{}代表查找到的文件，之间无空格，用\\;表示结束。 -ok：和-exec相同，只不过在操作前要询问用户 find命令支持用逻辑运算符来操作单个逻辑条件，或者将逻辑条件连接起来： –a 表示逻辑与 –o 表示逻辑或 ！表示取反 注意：使用多个条件时，这些条件要用圆括号括起来，左右圆括号还要使用反斜杠\\来进行转义，以防止shell的解释。 选项： 查找条件 -name ：查找名为filename的文件，即按文件名（使用通配符进行匹配，加单引号）查找 -iname ：与-name相同,只是忽略大小写（-i） -perm：按执行权限来查找 -user ：按文件属主来查找 -group ：按组来查找 -user ：按文件属主来查找 -amin ：按文件访问时间（access）来查找文件，-n指n分钟以内，+n指n分钟以前 -atime ：按文件访问时间来查找文件，-n指n天以内，+n指n天以前 -cmin ：按文件创建时间（create）来查找文件 -ctime ：按文件创建时间来查找文件 -mmin ：按文件更改时间（modified）来查找文件 -mtime ：按文件更改时间来查找文件 -empty：空白文件、空白文件夹、没有子目录的文件夹 -newer ：查更改时间比f1新但比f2旧的文件 -type ：查是块设备/目录/字符设备/管道/符号链接/普通文件 -prune：忽略某个目录 -size ：据文件大小查找文件，+n表示超过n大小的文件，-n表示小于n大小的文件 -size ：n表示文件大小的数值，b表示512字节的块，c表示Byte，k表示KB，M表示MB，G表示GB。 -type ：其中b表示块设备文件，c表示字符设备文件，d表示目录，p表示命名管道文件，f表示普通文件，l表示符号链接文件，s表示socket文件 举例： find ~ -size +100k \\( -name core -o -name '*.tmp' \\)：从主目录开始查找大于100KB的名为core或*.tmp的文件。圆括号前后面有空格！也可以写成：find ~ -size +100k '(' -name core -o -name \\*.tmp ')' find . -type d：从当前目录开始查找，寻找所有目录，打印路径名。按层次列出当前的目录结构。 chmod 字母形式：chmod [ugoa] [+-=] [rwx] file：对不同用户使用字符赋予不同权限。 u：user（主用户）、g：group（组用户）、o：other（其他用户）、a：all（所有用户） 数字形式：chmod 3位八进制数 file 修改文件权限： -R, -- recursive：以递归方式修改所有文件及其子目录。 权限对于文件和目录： r w x 文件 读取文件 编辑文件 执行可执行文件 目录 列出目录内容 移动、建立、删除文件/目录 进入目录 chmod 777 a.c # 将a.c文件的权限改为777 chmod +x a.c # 为a.c文件添加执行权限（3个用户都添加执行权限） ls -F：为不同类型的文件添加后缀 目录：在文件名后加/ 可执行文件：* 符号链接文件：@ 普通文件：无任何标记 -d：directory，当ls 的参数是目录时，不像默认情况那样列出目录下的文件，而是列出目录自身的信息 ls -l显示的7个字段，如下所示： -rwxr-xr-x 1 root root 87 Mar 20 21:49 s.py 字段 字段1 字段2 字段3 字段4 字段5 字段6 字段7 显示 -rwxr-xr-x 1 root root 87 Mar 20 21:49 s.py 含义 类型和权限 连接数 拥有者 文件组 文件大小 被修改时间 文件名 字段1有10个字符（第 11 个字符与SELinux 相关，我们此处不作讨论），分为4组： 文件类型。 剩下的9个字符分为3组，分别代表文件拥有者、文件组用户、其他用户 在该文件上拥有的权限。读（r）、写（w）、执行（x）和无权限(-) 字段5显示文件大小，默认为字节（Byte），可使用-h（--human-readable）选项让其更加易读。 普通文件：列出文件大小 目录：列出目录表大小，不是目录下文件长度和 符号链接文件：列出符号链接文件自身的长度，不是指向的那个文件 字符/块设备文件：列出主设备号与次设备号 管道文件：列出管道内的数据长度 文件类型分类： 字符 - d l c b p s 意义 常规文件 目录文件 符号链接 字符特殊设备 模块特殊设备 FIFO管道 套接字 ll ll == ls -l grep global regular expression print grep 模式 文件名列表 选项： -n：显示行号。如果只跟一个文件，它只会显示行号，不会显示文件名。 -v：显示所有不包含模式的行 -i：字符比较时忽略大小写 grep时排除指定的文件和目录： grep -rn --exclude-dir=venv 'abcdefg' . grep -nR --exclude=\"cscope.out\" --exclude=\"tags\" 'abcdefg' . 其他命令 egrep：使用扩展正则表达式，在指定模式方面比 grep 更灵活。 fgrep：快速搜索指定字符串，按字符串搜索，而不是按模式搜索。 cp cp file1 file2：复制file1为file2。 cp 文件列表 dir/：将多个文件复制到dir目录下。 复制文件： -R，-r， --recursive： 递归复制目录及其子目录的所有内容。 -s： 只创建符号链接而不复制文件。 -l：只创建硬链接文件而不复制文件。 cp a.c dir/ # 复制a.c到dir目录下 cp a.c dir/b.c # 复制a.c到dir目录下，并重命名为b.c rm 删除（unlink）文件： -f ：强制删除（Force）。忽略不存在的文件，不提示确认。 -i ：在删除前需要确认 （inform，默认选项）。 -R ：递归（Recursive）删除目录及其内容。 mv 移动文件或目录（可以直接移动目录）。此外，还可以用于重命名。 mv a.c dir/ # 把a.c移动到dir目录下 mv a.c b.c # 把a.c重命名为b.c（当前目录下没有b.c文件） su 在不退出当前登录的情况下，临时切换用户身份： -或-l：在切换用户时，也切换到相应用户的登陆环境，包括家目录、shell定义等。 不带用户名参数，默认切换到root用户。即su -等价于su - root。 su只适合一两个人参与管理的系统，多人管理使用sudo命令。 sudo sudo命令允许规定的用户能够以在许可范围内以其他用户身份执行规定的命令。即分配给普通用户一些root用户才拥有的权限。 sudo命令可以提供日志，忠实地记录每个用户使用sudo命令做了些什么，并将日志传送到中心主机或日志服务器。 sudo的配置文件为/etc/sudoers。 sudo -u 用户名 命令：使用某用户执行命令，-u省略时使用root用户。 sudoers文件讲解： ## Allow root to run any commands anywhere root ALL=(ALL) ALL # 用户 可登录的主机 =（可切换的用户身份列表 ） 可使用的命令列表 appwhy localhost=(root) /sbin/shutdown -h -5 %group_p 192.168.13.3=(root) NOPASSWD:/sbin/shutdown -h -5 # 用户组，免密 上述配置表明root用户可以在任何地方（远程终端）登录，并且以任何用户身份执行命令。 appwhy用户可以在本地登录，以root身份执行/sbin/shutdown -h -5这个命令。命令需要指定绝对路径。 whoami 查看当前用户名 id id user：查看用户的uid、gid、用户所属用户组的信息。如果不指定用户，则显示当前用户的信息 w 查看当前登录系统用户，及其详细信息。 xargs xargs 命令把标准输入追加到它的参数列表后面，再作为一个命令来执行。 xargs 经常与 find 配合使用。 链接 在 Linux中， 一个文件本身的数据总是放在在一个块 （block ）或者块的集合中文件的信息 （包括 文件类型、 读写权限、文件所有者、文件组、文件大小、文件链接数目，时间戳等 ）放在一个 inode 中，一个文件只对应一个 inode，而且这个 inode 在本文件系统内时唯一的。 在 Linux中，一个目录总是包含一个条目清单，所有此目录中的文件或子目录都在该清单中有一个条目，该条目包含这个文件名或目录名，已经指向该文件或目录的 inode的指针。 在Linux中，链接有两种： 符号链接(symbolic link，也成为symlinks) ：是指向包含另一目录条目的文件的一个目录条目。 硬链接 (hard link)：是文件或目录的另一个附加目录条目，允许同一文件或目录拥有多个名字。 通俗来说，文件的硬链接就可以理解为一个别名，而符号链接则可以视为文件的一个快捷方式。 普通用户没有创建目录硬链接的权限，只有root可以过ln –d命令强制为目录创建硬链接。创建目录硬链接有可能会在文件系统中引入遍历的死循环。 删除一个符号链接不会影响到这个符号链接指向的目标文件或目录。反过来，删除、移动、重命名符号链接指向的目标文件，不会导致这个符号链接被删除，只会让这个符号链接“断裂”。 如果一个文件有多个硬链接，仅在其最后一个硬链接被删除且硬链接数为0时，文件才会真正从文件系统中删除。 由于 inode 仅在 一个文件系统 (分区 )内是惟一的，因此硬链接不能跨越文件系统。 符号链接没有上面的限制，具更大灵活性，甚至可以跨越不同机器、不网络对文件进行链接。 ln 创建链接：默认创建硬链接 -s：创建符号链接 ln TARGET LINK_NAME # 创建关于TARGET的链接 ln TARGET # 在当前目录创建关于TARGET的链接 ln TARGET... DIRECTORY # 在指定目录中创建TARGET的链接 ln -t DIRECTORY TARGET # 通配符与正则表达式 正则表达式：文本处理 文件名匹配：文件处理 通配符 通配符(wildcard)，这种支持也称为“globbing”（因为它最初被实现为一个名为 /etc/glob 的程序），让你能够使用通配符模式指定多个文件。 我们常常在 ls、cp、mv 或 rm 命令中需要操作多个文件或目录名时使用通配符。 任何包含 *、? 或 [ 字符的字符串就是一个通配符模式。 *：匹配0个或多个字符。 ?：匹配任意一个字符 [list]：匹配list中的任意单一字符。a[xyz]b 匹配axb、ayb、azb。 [!list]：匹配除了list中的任意单一字符。a[!0-9]b 表示 a与b之间必须也只能有一个字符，但不能是阿拉伯数字。 [c1-c2]：匹配 c1-c2 中的任意单一字符。如：[0-9]、[a-z]、[0-9a-fA-F] {s1,s2,s3,...}：匹配s1/s2/s3中的任意一个字符串。 注意： *和 ? 字符与它们自身匹配。如果在文件名中使用这些字符，那么需要注意适当的引用或转义。 !在Shell中是有特殊含义的，因此需要小心地对它进行适当的转义。 文件通配符被单独应用到路径名的每个组成中。但我们无法匹配/。 命令中的任何通配符都可以被 shell 进行扩展，这将导致意外的结果。在使用 cp、mv 或 rm 出现异常行为之前，使用 ls 检查你的通配符模式。 注： . 作为文件名（如 .bashrc）或者路径名（如 ./aa.txt）的第一个字符时，必须显示匹配。 路径分隔符 / 也需要显示匹配 ~：当前用户主目录 ~appwhy：用户appwhy的用户主目录 - 是可以作为文件名开头的，但是在使用相关命令时需要特殊处理。如Linux 命令 (如cp ，ls ，mv ，rm ，cat ，grep ，set 等)，用-- 显式地标志命令行选项的结束，识别以 - 开头的处理对象。如：rm -- -i， 删除文件 -i 。 正则表达式 6个元字符：.，*，[，$，^，\\。 .，*，\\在方括号内时，代表他们自己。即[\\*.] 表示匹配三个单字符 其他字符： -：定义一个区间，如[a-z]、[][]（匹配 ] 、[）。若符号在最后面，则没有区间的意义。 ^：表示补集，如[^a-z]匹配任意非小写字母。如果^不在开头，则没有补集的意义。 锚点： $：在尾部时有意义，否则与自身匹配。123$表示匹配文件中行尾的123，不在行尾的123则不匹配。 ^：在首部时有意义，否则与自身匹配。^123表示以123开头。 扩展的正则表达式（ERE）： ()：表示分组 (xy)* 可匹配 'xy'、'xyxy'，'xyxyxy' (abc|123)：与'abc'或'123'匹配。 重复次数定义 *：0次或多次重复 +：1次或多次重复 ?：0次或1次重复 \\{m,n\\}：重复m到n次 命名的预定义。如\\d表示数字。 重定向 Bash实际上使用三种标准输入输出流： 标准输入流（stdin），向命令提供输入，文件描述符是 0。 标准输出流（stdout），显示来自命令的输出，文件描述符是 1。 标准错误输出流（stderr），显示来自命令的错误输出，文件描述符是 2。 对于任何一条linux 命令执行，它会是这样一个过程： 一般情况下，我们可以将stdout和stderr视为终端屏幕或者终端窗口，而将stdin视为终端键盘。 输出重定向 输出重定向： n>：表示将来自文件描述符 n 的输出重定向到文件。必须对这个文件有写权限。如果文件不存在，就创建它。如果它存在，将覆盖原有文件内容。 n>>：表示将来自文件描述符 n 的输出重定向到文件。同样，必须对这个文件有写权限。如果文件不存在，就创建它。如果它存在，输出就附加到现有文件后面。 n代表文件描述符。如果忽略，就假设是标准输出。 使用 &> 或&>> 将标准输出和标准错误重定向到同一个位置。 2>&1 表示将文件句柄2重定向到文件描述符1指向的文件。 ./stda >rpt 2>&1：stdout与stderr均存入文件rpt。 ./stda 2>&1 >rpt：stderr重定向到终端，stdout重定向到文件rpt。 有时候希望完全忽略标准输出或标准错误。为此，可以把重定向到/dev/null中。 输入重定向 输入重定向： 使用 操作符将 stdin 重定向为来自文件。 ：从shell脚本中获取数据，直到遇到定界符word。在此期间，如果遇到$HOME 或 'date'（实际括住date的是反单引号，这里显示不出来，用单引号代替），会将其替换成具体的值。 ：不对定界符之间的内容进行替换。 ：str是一个字符串，这里会将其作为一个文件进行重定向。 Bash还有 here-document 的概念，这是输入重定向的另一种形式。这使用 以及一个单词（比如 EOF），这个单词作为输入结束的标志。 管道 本质上来说，管道就是一种特殊的重定向，也就是对一个命令的输出（stdout）进行管道连接（即重定向），用作下一个命令的输入。 管道命令只处理前一个命令正确输出，不处理错误输出。 管道的右边命令，必须能够接收标准输入流命令才行。 常用来作为接收数据管道命令有：sed, awk, cut, head, tail,top, less, more, wc, join, sort, split 等等，都是些文本处理命令。 查看机器相关信息 cat /etc/centos-release # 查看发行版本号 查看发行版本号 # CentOS Linux release 7.4.1708 (Core) uname -r # 查看内核版本号和机器架构 # 3.10.0-693.el7.x86_64 查看文本文件 查看与语言有关的环境变量设置 env | grep LANG export LANG=en_US.UTF-8 # 设置编码 编码转换： iconv -f gbk -t utf8 file # 将文件的编码从gbk改为utf8 file file 文件名：查看该文件信息，如使用的编码。 cat concatenate cat a.txt 或 cat a.txt b.txt 。 将[文件]或标准输入组合输出到标准输出。如果没有指定文件，或者文件为-，则从标准输入读取。 -b：对非空内容 输出行编号。 -E：在每行的未尾添加$符号，便于确认每一行，因为有些行内容太长了，在显示时会在显示器上以多行表示。 -n：对输出的所有行编号 -s：将相连的多个空行用一个空行来代替 -T：将Tab字符显示为^I 常用命令： cat > try：从stdin获取数据，存入try中，直到按下Ctrl + D 。 od octal dump，逐字节打定文件，可以使用不同的进制输出文件。 od -t x1 x.dat ： 以16进制打印x.dat。 less 对文件或其它输出进行分页显示。逐屏显示文件 -n：对输出的所有行编号 -M：输出打开的文件名，当前显示的行数，总行数和光标当前所处文档位置 -s：将相连的多个空行用一个空行来代替 -S：截断过长的行而不换行显示 快捷键： Enter：向下滚动一行 Space：向下翻页 q：quit，退出 /pattern：按指定模式（正则表达式）搜索字符串，/ 表示继续查找。 Ctrl + L：屏幕刷新 head head a.txt 或 head a.txt b.txt 。 将每个指定文件的前10行显示到标准输出。如果不指定文件，或者文件为\"-\"，则从标准输入读取数据。 -n K：显示文件的前K 行内容。当K为负数时，表示不输出后|K|行。 -c K：显示每个文件的前K 字节内容。 tail 显示每个指定文件的最后10 行到标准输出。 -n K：显示文件的最后K 行内容。当K前面有 + 时，表示不输出前K行。 -c K：显示每个文件的最后K 字节内容 -f：实时打印文件尾部被追加的内容（forever ）。tail -f log.log wc word count 统计文件的行数、单词数、字符数（Byte）。 -l：只列出行数。ps aux|wc -l：统计有多少个进程。 tee 将从标准输入stdin得到的数据抄送标准输出stdout进行显示 ，同时存入磁盘 文件中。 ./myap | tee myap.log： 将执行myap的结果输出到屏幕，并存储到日志文件在。 sort 对文件内容按行进行排序。 -n：Numberic， 对于数字按照算术值大小排序，而不是字符串比较。 tr translate tr string1 string2 把标准输入拷贝到标准出，string1中出现的字符替换为string2中对应的字符。 cat a.txt | tr '[A-Z]' '[a-z]'：将大写字母替换为小写字母 cat a.txt | tr % '\\012'：将%改为换行符（八进制）。 uniq 筛选文件中的重复行（紧邻的两行内容相同） 用法： 无参（-u或-d）时，打印没有重复的行和有重复的行，但重复的行只打印一次。 -u：unique，只打印没有重复的行 -d：duplicated，只打印重复的行 -c：count，对出现次数进行统计 sed 流编辑： sed 命令 文件名列表 sed –e 命令1 –e 命令2 –e 命令3 文件名列表 sed -f 命令文件 文件名列表 命令的模式： s代表substitute，替换。 g：如果一行中有多个匹配，则全部替换。 s/\\([0-9][0-9]\\)-\\([0-9][0-9]\\)-\\([0-9][0-9]*\\)/3.\\1.\\2/g：将 04 -26 -1997 替换为 1997.04.26。 awk 逐行扫描处理文本 awk分别为该程序的三位设计者姓氏的第一个字母 awk 命令 文件名列表 awk -f 命令文件 文件名列表 命令格式： BEGIN { action; } condition { action; }; END { action; } # 允许多段程序：段程序间用空格或分号隔开 处理方式： 输入文件的每行作为一个输入，变量 NR 就是行号。 每行用空格分隔开的部分，叫做记录的“域”，内置变量 $1 是第 1域内容，$2 是第 2域内容。特别的， $0 指的是整个这一行的内容。 awk 的处理为：符合条件的行，执行相应的动作。 命令编写： 使用与C语言类似的关系运算符：/>= 逻辑运算符：条件非!，条件与&&，条件或|| 可以使用正则表达式 特殊条件 不知道任何条件，则对所有文本执行动作 BEGIN：开始处理文本之前，执行动作 END：处理完所有文本之后，执行动作 描述动作 自定义变量 加减乘除等算术运算 正则表达式匹配运算符：~、!~。如$2 ~ \"[0-9]\" 流程控制：if、for print var1 var2 printf(\"%s %s\", var1, var2) 举例： ps -ef | awk '/guest/{ printf(\"% s \", $2); }' awk '{ printf(\"%d: %s\\n\", NR, $0); }' test.c date | awk '{print $4}' ls -ls | awk '$5>10 {print $10}' cmp cmp file1 file2 两文件逐字节比较，看是否完全相同。两个文件完全相同时，不给出任何提示；不同时，打印出第一个不同之处。 在Windows中有类似的命令COMP。 diff 比较两个文本文件，以寻找二者之间的差别 diff file1 file2 # normal。显示中有a(add)、c(change)、d(delete) diff -u file1 file2 # unified。类似于git中文件的比较 md5sum/sha1sum 常用于数据完整性 （Data Integrity）验证和判断位于网络不同机器上的两个文件内容是否相同。 使用 MD5 算法（散列函数）根据文件内容生成 16 字节 hash 值，比较 hash 值是否相同，就可断定两文件内容是否完全相 使用SHA-1算法的命令名为sha1sum (20 字节 hash 值) 其他散列函数也可以用来完成这一任务：sha512sum(64字节，512bit) 跨机器对比文件： 在机器A上运行md5sum 文件列表 > myfiles.sum，并将myfiles.sum传输到机器B上。 在机器B上运行 md5sum -c myfile.sum，对机器A、B上的文件进行比较。 失误率： MD5：pow(2, -128) SHA-1：pow(2,-160) vim vim有3种模式： 一般模式（NORMAL）：会在屏幕的底部显示文件名或者是空白。在打开vim 时默认处于一般模式。可以执行大量操作。 输入模式：底部会显示–INSERT–。 命令行模式：键入:进入。 可视模式：底部显示的是–VISUAL–。可使用 d 删除选择内容，y 复制选择内容。 v：进入字符选择模式。 Shift+v：进入行选择模式 Ctrl+v：进入块（区域）选择模式 搜索模式：键入/ （正向查找）或 ?（反向查找） 进入。按n 或N 进行正向或反向遍历。 \\*：查找光标所在位置的单词。 :n1,n2s/word1/word2/g：在第n1和第n2行之间，查找word1这个字符串，并用word2来替换。 :1,$s/word1/word2/g：在整个文件中，查找word1这个字符串，并用word2来替换。 :n1,n2s/word1/word2/gc：在替换前询问使用者是否替换（conform）。 无论编辑器当前在什么模式， 按下 Esc 键，它都会回到一般模式。有时需要按两次Esc。 一般模式下移动光标： 快捷键 h/← j/↓/Enter k/↑ l/→ ^/0 $ w b G 含义 左移 下移 上移 右移 行首 行尾 下一个单词 上一个单词 最后一行 快捷键 H M L 含义 光标移到屏幕最上方那一行 光标移到屏幕中间那一行 光标移动到屏幕最下方那一行 快捷键 gg nG n$ Ctrl+o f/F 含义 第一行 第n行行首 第n行行尾 回到上一次光标所在位置 向后/前搜索字母并移动光标 快捷键 Ctrl+f/PgDn Ctrl+b/PgUp Ctrl+d Ctrl+u 含义 屏幕向下移动一页 屏幕向上移动一页 屏幕向下移动半页 屏幕向上移动半页 快捷键 >> Ctrl+l Ctrl+g 含义 整行向左缩进 整行向右缩进 刷新屏幕（load） 显示文件状态，行数、行号等 一般模式下对文本进行删除： 键 x/Delete X/BackSpace d^ d$/D dd dw/daw/dnw dG d1G 含义 删除光标所在的字符 删除光标前的字符 删除至行首 删除至行尾 删除/切剪当前行 删除1/n个单词 删除至文档结尾 删除至文档首部 还可以在命令前加上数字，表示执行多次相同操作。如5dd表示删除5行。 其他命令： 键 J u/u {n} Ctrl+r Shift+z+z . ~ 含义 删除换行符 撤回1/n次修改 redo，反撤回 保存并退出 重复上一次操作 大小写转换 键 yy y^/y0 p P ddp 含义 复制当前行 复制到行首（不含光标） 粘贴到光标后 粘贴到光标前 交换光标所在行与下面一行 键 r R cc C 含义 替换光标处的字符 连续替换，直到按Esc 删除当前行并进入插入模式 删除至行末并插入 把光标移到一个括号（()/{}/[]）上，按 % 可以快速将光标移动到与其匹配的另一个括号上。 从一般模式进入插入模式： 快捷键 i I a A o O 含义 当前光标 行首插入 光标后插入 行尾插入 在当前行下面插入新行 在当前行上面插入新行 命令行模式 在命令行模式下，可以使用 :! 外部命令 执行外部的shell命令。如 :! ls 显示当前目录内容。 键 :ce :ri :le 含义 是本行文本居中（center） 靠右（right） 靠左（left） 键 :10,50d :1,.d :.,$d :10,50y 含义 删除10到50行 删除文件首行到当前行 删除当前行到尾行 复制10到50行 键 5,10co56 :5,10m56 含义 复制5-10行到56行下 移动5-10行到56行下 命令模式下，常用命令： 键 w w wq q q! e 含义 保存修改 另存为 保存修改并退出 退出 不保存，强制退出 打开相应文件 键 r n1,n2 w e! 含义 将filename中的内容插入当前行的后面 将n1到n2行的内容保存到filename中 将文件还原到最初状态 进行设置： 键 set nu set nu? set shiftwidth=10 set all 含义 显示行号 查看\"显示行号\"的属性 设置缩进为10 显示所有设置 要获取帮助命令，输入:help 或者按下 F1 键。 vim 会显示一个帮助概览的窗口。 同时编辑多个文件 vim a.txt b.txt：默认进入a.txt的编辑页面。 :n：向后切换到b.txt的编辑页面。可以使用:n!进行强制切换，即不保存修改。 :N：反向切换 常用命令： :e 3.txt：打开新文件 :e#：回到前一个文件 :files：列出目前这个vim打开的所有文件 :ls：列出以前编辑过的文档 :ls 1 # \"a\" line 1 2 %a \"tp.py\" line 7 :b tp.py 或者 :b 2：直接进入tp.py进行编辑 :f：显示正在编辑的文件名 :f new.txt：将当前正在编辑的文件copy一份，命名为new.txt，需要:w保存后才会正在创建。 视窗操作 vim可以在一个界面中打开多个窗口进行编辑，这些编辑窗口称为vim的视窗。 常用命令： new：打开一个水平视窗。 sp 1.txt：打开新的水平分屏视窗来编辑1.txt。省略文件名，表示两个窗口为同一文件内容，同步显示。 vsp 2.txt：打开新的垂直分屏视窗来编辑2.txt Ctrl+w s：将当前窗口分割成两个水平的窗口 Ctrl+w v：将当前窗口分割成两个垂直的窗口 Ctrl+w q：即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q! Ctrl+w o：打开一个视窗并且隐藏之前的所有视窗 Ctrl+w j：移至下面视窗 Ctrl+w k：移至上面视窗 Ctrl+w h：移至左边视窗 Ctrl+w l：移至右边视窗 Ctrl+w J：将当前视窗移至下面 Ctrl+w K：将当前视窗移至上面 Ctrl+w H：将当前视窗移至左边 Ctrl+w L：将当前视窗移至右边 Ctrl+w -：减小当前视窗的高度 Ctrl+w +：增加当前视窗的高度 其他 vim的配置文件为~/.vimrc， 由于断电等意外原因没有保存文档，可以使用vim -r 进入文档后，按:ewcover a.txt 来恢复a.txt文件。 当编辑一个文件时，在这个文件所处的目录底下就会有一个临时文件，文件名为 编辑的文件名.swp，这是一个隐藏文件， 所有修改都会暂时存在这个文件中。在编辑过程中，系统或者 vi 非正常关闭了，那么再重新用 vi 打开这个文件时，系统就会询问是否『Recovery』。按下 R ，就可以将数据回复到修改 ，就可以将数据回复到修改过程的样子，再将 swp 文件删除。 vim -x a.txt：对a.txt进行加密，需要保存后才能生效。 vim的“死机”现象：vi 编辑结束后执行存盘操作，结果导致屏幕卡死，输入任何信息都 再有显示（死机，终端死机）。原因是 vi 编辑结束后按下 Ctrl+S，因为 Windows编辑器一般设置 Ctrl+S热键的动作为 Save ，但 Linux 却进入流量控制状态。解决方法是按下 Ctrl+Q 后流量控制解除。 流量控制：终端的显示速度跟不上主机的发送速度，需要对主机发送的内容进行暂停显示。 意外终止问题：vi 编辑结束后存盘，程序意外中止，编辑成果丢失，文件内容未发生变化。原因是vi存盘命令为 Shift+z+z， 结果按错成 Ctrl+z+z，而Ctrl+z按键导致当前运行程序被挂起（suspend），暂停了运行。解决方法：调用bash作业的管理机制，恢复运行stopped状态的进程： jobs：列出当前被Stopped的进程 fg %1 或 %1：将1号作业恢复到前台（foreground）运行 linux用户，uid 用户 (user) 是能够获取系统资源的权限集合 。Linux中的用户可 以分为三类： 根用户 (root)：具有系统全部权限的用户。登陆后的提示符为 # 。UID=0 普通用户：其使系统的权限受到一定制。登陆后的提示符为 $ 。UID>=100（或者1000） 系统用户：也称虚拟用户，是保障系统运行的用户，一般不通过Shell 登录系统 。 用户组（ group）就是具有相同特征的用户（ user）的集合体 。 UID 是确认用户权限的标识，用户登录系统所处的角色是通过UID 来实现的，而非用户名，因此，每个用户的UID必须是唯一的。 CentOS系统会把前 499个 UID 预留出来， 给系统虚拟用户占用，虚拟用户一般是系统安装时就有的，为了完成任务所必须的用户。但虚拟用户是不能登录系统的，比如 ftp、nobody、adm 、rpm 、binbin 、shutdown等。 有的系可能会把前 999 UID 和 GID 预留出来。 以各个系统的/etc/login.defs中的UID_MIN为为准。 用户和用户组的对应关系可以是一对一、多对一、一对多、多对多， 一个用户可以从属于多个用户组，一个用户组也可以包含多个用户。但在同一时间内，一个用户的主用户组（primary group）或者说有效用户组（effective group）只能有一个。 在默认情况下每个新建的普通用户都从属于一个单独的和用户名同名的用户组。 查看用户可以使用两个命令id和finger（finger命令系统不自带）。 id工具更侧重用户、用户所归属的用户组、UID 和GID 的查看 finger侧重用户信息的查询，比如用户名（登录名）、家目录、登录SHELL类型等等。 增删改用户或用户组： 使用相关命令 直接修改相关配置文件 以上命令的本质是修改如下文件： /etc/passwd和/etc/shadow：passwd是系统识别用户的一个文件（系统通过该文件和用户名找到用户对应的uid），shadow存放用户密码。 /etc/group和/etc/gshadow：用户组的配置文件，内容包括用户和用户组，并且能显示出用户是归属哪个用户组或哪几个用户组。 passwd文件字段解释：root:x:0:0:root:/root:/bin/bash 字段 root x 0 0 root /root /bin/bash 解释 用户名 密码 uid GID 用户全名（可选） 家目录 shell类型 /etc/shadow文件是/etc/passwd的影子文件，这个文件并不由/etc/passwd而产生的，这两个文件是应该是对应互补的；shadow内容包括用户及被加密的密码以及其它/etc/passwd不能包括的信息，比如用户的有效期限等。 useradd 用户名 # 为系统添加一个用户，包括 用户名、用户ID ，以及Home目录 usermod 用户名 userdel 用户名 # 删除某个用户。-r：表示在删除用户的同时，一并把用户的家目录及本地邮件存储的目录或文件也一同删除，慎用。 passwd 用户名 # 为用户修改密码。root用户可修改其他用户。 groupadd 用户组名 # 为系统添加一个新用户组 groupmod 用户组名 groupdel 用户组名 # 在删除用户组的时候请万分小心，因为这有可能涉及到其它和这个用户组相关的用户。如果有用户将这个用户作为主用户组(primary group)，则不能删除。 文件系统 /bin：用户和管理员必备的二进制文件。系统常用命令 /sbin：系统管理员必备，但是一般用户根本不会用到的二进制文件 /usr：usr指Unix System Resource，而不是User。 /usr/bin：不是用户必备的二进制文件。都是系统预装的可执行程序，会随着系统升级而改变 /usr/sbin：不是系统管理员必备的工具 /usr/local/bin：是给用户放置自己的可执行程序的地方。推荐放在这里，不会被系统升级而覆盖同名文件。 /usr/include/：C语言头文件存放目录 /usr/lib/：和 /lib/目录一样。 /usr/src/：存放需要使用源码安装的软件博爱源码 /etc/：提供系统维护管理用的命令和配置文件。文件格式为文本文件，功能类似于windows的注册表。 主要文件：passwd、hosts、*.conf。 主要目录：ssh、xinet.d、apt、network 系统启动阶段系统初始化和启动服务的脚本 rc*.d 。存放不同运行等级的启动脚本的链接文件 自定义的需要自启动的服务脚本 rc.local。 profile、bashrc 系统级bash等shell的偏好设置。 /tmp/：临时文件，每个用户都可以在这里临时创建文件，但只能删除自己的文件，不可以其他用户创建的文件。 /var/：系统运行时要改变的数据、系统日志syslog等。 /dev/：设备文件，如终端设备、磁带机、打印机等。 /lib/：Linux广泛使用动态链接库，静态链接库已经逐渐过时。 各种库文件（如C语言的链接库文件，terminfo终端库等） 静态链接库文件，.a 后缀（archive，存档） 动态链接库文件，.so后缀（shared objects，共享的目标代码，多个.o 文件的集成） /boot/： grub/：开机设置相关文件 vmlinuz：内核文件 /media/：cdrom、floppy、u盘，用于挂载本地磁盘或其他存储设备 /mnt/：挂载其他临时文件系统。 /opt/：发行版附加的一些软件包的安装目录。 /srv/：存放服务进程所需的数据文件（如www网络服务、ftp服务器）和一些服务的执行脚本 /bin、/sbin目录是在系统启动后挂载到根文件系统中的，所以这两个目录必须和根文件系统在同一分区。/usr/bin、usr/sbin可以和根文件系统不在一个分区。 硬盘管理 使用fdisk -l查看磁盘信息。 对磁盘进行分区 ( Partition ) 前，磁盘是无法用来存储数据的。事实上，对磁盘进行分区的作用就是告诉操系统，磁盘可存储数据的区域，也即每个分区的起始柱面和结束柱面。 这些分区信息都包括在一个叫做分区表（Partition Table ） 的数据结构中。 分区表是一块磁盘中最重要的数据，一般存储在磁盘的0磁道上面 （所以 当一个硬盘的0磁道发生了物理损坏的时时候，这个硬盘就基本宣告寿终正寝了 ）。 硬盘仅为分区表保留了 64 个字节的存储空间，而每分区参数占据 16个字节的存储空间，故主引导扇区中总计可以存储 4个分区的数据， 这就是 主分区 （Primary）+扩展分区 （Extended） 最多只能有四个的原因了。 对硬盘进行分区主要使用命令fdisk。 如上图所示，可分为4个区，3个主分区，1个扩展分区（该分区又被划分为3个逻辑分区）。 使用mount、unmount命令来挂载和卸载设备。 mount # 不带参数，列出当前已经安装的所有子文件系统 mount 分区/设备名 挂载目录 unmount 分区/设备名/挂载目录 mkfs /dev/sdb：在块设备文件上创建文件系统（make filesystem） mount /dev/sdb /mnt： /mnt 是预先创建好的一个空目录。挂载子文件系统。 dh df命令显示所有文件系统和磁盘块的使用情况，可使用参数-h让输出更易读。 网络配置与管理 查看网络接口是否启动并配置好，我们可以使用ifconfig命令来完成 。 用ifconfig来改变接口的 配置参数是临时,也就是说 ,如果系统重启 ,或者网络重启的话 ,这些改变的参数是不会保留下来的。 ifconfig eth0 up # 启动网络接口eth0 ifconfig eth0 down # 关闭网络接口eth0 ifconfig eth0 172.168.19.54 netmask 255.255.255.054 # 设置接口eth0网络地址为 172.168.19.54，子网掩码为255.255.255.0 linux系统中与网络配置有关的文件： /etc/services： /etc/host.conf： /etc/nsswitch.conf： /etc/xinetd.conf： /etc/modules.conf： /etc/sysconfig/network：为主机设置全局网络参数（不针对单个网络接口）。GATEWAY参数会被/etc/sysconfig/network-scripts/ifcfg-ethN中的同名参数覆盖。 /etc/hosts：是一个用于储存计算机网络中各节点信息的文件，负责将主机名映射到相应的IP地址。hosts文件通常用来补充或取代小型网络中DNS的功能。 IP地址 主机名（Hostname） 主机别名（Alias） /etc/resolv.conf：DNS客户端配置文件。 /etc/sysconfig/network-scripts/ifcfg-ethN：N是一个具体数字，代表主机网络接口的序号。 注意， 网络接口配置文件中的某些会影响到 主机上其他网络接口甚至整 个整主机网络配置。 netstat netstat是一个监控本机端口状态的的工具。输出网络连接 , 路由表 , 接口统计数据 , 伪连接 ,及多播成员的相关信息。 -l：显示正在监听的连接（不显示已经建立的连接） -t：只显示tcp连接 -u：只显示udp连接 -n：以数字形式显示地址和端口号 -p：显示连接从属的进程PID和进程名称 -a： 显示所有连接和监听端口 netstat -ltp：查看监听中的TCP连接。 字段意义： Proto：连接使用的协议，主要是TCP和UDP。 Recv-Q：尚未接收的字节数。 Send-Q：尚未发送到目标的字节数。 Local Address：本机地址 主机IP:端口号。如果ip为0.0.0.0或*，表示在所有链接的相应端口。如0.0.0.0:22就表示在本机所有链接的22 端口上都进行监听。 Foreign Address：目标地址与端口。 State：当前Socket连接的状态。 ESTABLISHED：连接已建立 SYN_SENT：正在尝试建立连接（发出SYN标志） SYN_RECV：接收到一个建立连接的请求 FIN_WAIT1：socket关闭，正在进行连接中断 FIN_WAIT2：连接已中断，但socket正在等待对方回应。 TIME_WAIT：连接已中断，socket仍在等待，处理仍存在于网络中的包。 LISTEN：已建立监听，socket正在监听端口输入，但尚未建立连接。 软件包管理 RPM （Red Hat Package Manager）包管理器（简称 RPM ，全称为 The RPM Package Manager）是Linux下广泛使用的软件包管理器。 RPM 包管理器只能管理以RPM形式封装的软件包 每个 RPM 软件包是一个压缩的文档，包含了内容信息、应用程序文件、图标，文档和用作管理的脚本。 tsclient-0.132-6.i386.rpm： 字段 tsclient 0.132-6 i386 含义 软件包名称 带有版本号和发行版本的软件包名称 硬件架构 硬件架构： 架构 适用机器 i386 适于任何现有的 Intel兼容计算机 noarch 适于所有架构 ppc 适于 PowerPC系统，如Apple Power Macintosh x86_64 适于64位Intel处理器，如 Intel Core i7 rpm 包有二进制安装 包（ Binary）以及源代码安装包（Source）两种。 二进制包可以直接安装在计算机中，而源代码将会由 RPM 自动编译、安装。二进制包常以 rpm作为后缀名，源代码包经常以 src.rpm 作为后缀名。 rpm [选项] 软件包名：RHEL和 CentOS中自动安装、配制、卸载和升级软件包的工具组合。 -i ：安装软件，经常-ivh连用。 -v：显示安装时的详细信息。 -h：安装时输出#最为进度条。 -e ：卸载软件。 -q ：查询软件包。 -a：列出所有软件包，常-qa连用。 RPM 有一个久为用户诟病的缺点，就是无法解决软件依赖问题。究其原因，正是 由于 RPM 程序是已经打包好的数据，也就是说，里面的数据已经都编译完成，所有安装时一定需要当初安装时的主机环境才能安装。当初建立这个软件的安装环境必须也要在当前主机上重现才行 。 yum YUM（Yellow dog Updater Modified）是为了解决 RPM 的依赖关系问题，方便使用者进行软件的安装、升级等工作 。 yum只是为了解决RPM的依赖关系，而不是一种其他的软件封装模式，可以将yum视为RPM的一个前台工具。 每一个 RPM 软件包的头（ header ）里面都会纪录该软件的依赖关系， yum就是通过分析header得到相关的依赖关系。 当第一次使用 yum 或 yum 源有更新时 ，yum会自动下载所有所需的headers 放置于/var/cache/yum目录下，所需时间会比较长。 常用命令： yum clean all：清除缓存中旧的rpm头文件和包文件。 yum makecache：建立新的缓存。 yum list：列出所有升级源上的包。 yum list available：列出资源库中所有可以安装或更新的 rpm 包。 yum list updates：列出所有升级源上的可以更新包。 yum list installed：列出已经安装的包。 yum search ：搜索rpm包。 yum info ：列出资源库中特定的可以安装或更新，以及已经安装的 rpm 包的信息。 yum install ：安装rpm包。 yum update ：更新rpm包。 yum remove ：卸载rpm包。 RPM软件源（Repositories）是一 个目录，或者一个网站，里面包含了许多 RPM 软件包及其索引文件，我们安装软件时就是从该软件源上下载的包。 有许多公司和社区提供 CentOS entOS entOS entOS entOS rpmrpmrpm官方 源，国内比较常用的有： 源，国内比较常用的有： 网易源： http://mirrors.163.com 搜狐源： http://mirrors.sohu.com 中科大源： http://centos.ustc.edu.cn CentOS源： http://mirror.centos.org 一个软件源（ Repositories）中可能会配置多个软件仓库（Repository）。Centos默认自带的CentOS-Base.repo源已经预先配置了5个仓库： base：构成 CentOS的基本软件包，和光盘上内容相同 。默认启动。 updates：Base 仓库中软件包的更新版本。默认启动。 extras：一大批附加的软件包。默认启动。 centosplus：针对 base 及 updates软件库内的组件的更新。这些更新的组件并不属于正式的发行，所以在扩展CentOS功能的同时，牺牲了与先前版本的兼容性。启用这个软件库会导致CentOS与正式版本有差别。默认不启动。 contrib：包含了CentOS用户贡献的组件，它们并不会与核心发行版本的组件重叠。这些组件并没有经过CentOS的开发者测试，也不一定会跟随CentOS的发行同步。 其他软件源： EPEL 源：https://fedoraproject.org/wiki/EPEL/zh-cn RepoForge源： http://repoforge.org RPMFusion 源： http://rpmfusion.org Remi源：http://rpms.famillecollet.com Atrpms源：atrpms.net ELRepo源：elrepo.org CentOS的软件源配置文件位于/etc/yum.repos.d/目录下。 自己配置软件源： 安装相关软件：yum install yum-plugin-priorities。 确保/etc/yum/pluginconf.d/priorities.conf文件下有如下内容： [main] enable=1 # 启动本插件 check_obsoletes=1 # 防止一些已经废弃 (obsoletes)的包出现 查看机器架构与CentOS版本信息，选择合适的软件源，进行下载： # 下载相关源，在http://repoforge.org/use/找的资源 wget http://repository.it4i.cz/mirrors/repoforge/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm # 安装源 rpm -ivh rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm # 此时在/etc/yum.repos.d/目录下就有新安装的软件源配置了 打开/etc/yum.repos.d/rpmforge.repo，在[rpmforge]最下面添加： [rpmforge] # 其他配置 priority = 10 优先级由 1 ~ 99 这99个数表示， 1 的优先级最高。 进程 程序是为了完成某种任务而设计的软件。而一个运行中的程序就被称为进程。 进程的一个比较正式定义是：在自身虚拟地址空间运行的一个单独的程序。 一个运行着的程序，可能包含多个进程。 进程分类： 交互进程：由一个shell启动的进程。既可以在前台运行，也可以在后台运行。 批处理进程：和终端没有联系，是一个进程序列。 守护进程：Linux系统启动时会自启动，并在后台运行。一般由系统在开机时通过 一个叫做 init 的脚本自动激活启动，或超级管理用户root来启动。它独立于控制终端，并且周期性地执行某种任务或等待处理某些发生的事件。 进程操作 快捷键： Ctrl+Z：挂起当前进程 Ctrl+C：终止当前进程 进程的恢复： fg或fg [n]：恢复到前台继续运行。 bg或bg [n]：恢复到后台继续运行。 jobs ：查看被挂起的进程。 ps（process status） ps是最常用的进程查看命令。 l：长格式输出 u：按用户名和启动的时间顺序来显示进程 j：用任务格式来显示进程 f：用树形格式来显示进程 a：显示所有用户的所有进程 x：显示无控制终端的进程 r：显示运行中的进程 --sort [+/-]：按指定顺序输出 ps aux # 最常用命令 ps aux --sort %cpu # 按cpu使用升序排列 ps aux --sort -%mem # 按内存使用降序排列 ps afux # 查看进程的父子关系 ps命令经常和grep命令一起使用，对进程进行筛选。 进程描述符（Process Descriptor）： USER：启动进程的用户 PID：进程标志号 PPID：父进程的PID。父子进程之间的关系是管理与被管理的关系，当父进程终止时，子进程也随之终止。反之则不一定。 %CPU：运行该进程占用CPU的时间与该进程总的运行时间的比例。 %MEM：该进程占用的内存和总内存之比。 VSZ：占用的虚拟内存大小。 RSS：进程占用的物理内存值。 TTY：进程创建时所对应的终端，?表示该进程不占用终端。 STAT：进程的状态 D：不可中断的睡眠 R：就绪（在可运行队列中） S：睡眠 T：被跟踪或停止 Z：终止（僵死，zombie）的进程 W：没有足够的内存分页可供分配 N：低优先序的进程 L：有内存分页分配并锁在内存体内（实时系统或I/O）。 +：位于后台的进程 s：进程的领导者（在它之下有子进程） START：进程开始时间 TIME：进程已执行的时间 COMMAND：对应的命令名 top top是一个动态监视进程的工具。默认情况下，每3秒刷新一次。 -d：指定更新的间隔，以秒为单位。 -q：没有任何延迟的更新。如果是root用户，top命令会以最高的优先序执行。 -c：显示进程完整的路径与名称。 数据段解释： VIRT：进程逻辑地址空间大小 (virtual) RES ：驻留内存数 (Resident)， 也就是占用物理内存数 SHR ：与其他进程共享的内存数 (share ) %CPU：占用CPU百分比 %MEM：占用内存百分比 TIME+：占用的CPU时间 与top交互的快捷键： space：立即更新 >：向下翻页 ：向上翻页 T：按进程运行时间排序，降序 M：按内存使用情况排序，降序 N：按进程id排序，降序 P：按CPU占用情况排序，降序 R：反向排序 k：结束指定进程 kill 终止进程：kill [-signal] pid -signal：表示向进程发出的信号 。如果没有指定任何信号，默认发送的信号为 SIGTERM（-15 ），可将指定进程终止。若仍无法终止该进程。可使用更强力的SIGKILL（-9）信号尝试强制终止进程 。 killall是通过程序的名字，直接杀死相关的所有进程。常用ps|grep配合使用。 kill 命令的工作原理是，向 Linux系统的内核发送一个操作信号和某个程序的进程标志号，然后系统内核就可以对进标志号指定的进程进行操作。 当需要终止一个前台进程的时候，通常使用ctrl+c组合键；但是对于后台进程就必须使用kill命令。 守护进程 守护进程经常以超级用户（root）保持运行。因为它们要使用特殊的 端口（1-1024）或访问某些特殊的资源。 守护进程是非交互式序，没有控制终端，所以任何输出（stdout、stderr）都需要特殊处理。 分类： 系统守护进程：为系统提供某种重要的功能。 网络守护进程：向用户提供某种网络服务。 Linu x守护进程的工作模式是服务器 /客户端（Server/Client），服务器在一个特定的端口上监听（Listen）等待客户连接，连接成功后服务器和客户端通过端口进行数据通信。守护程的工作就是打开一个端口，并且监听（Listen）等待客户连接。如果客户端产生一个连接请求，守护进程就创建（Fork）一个子服务响应这个请求，而主服务器继续监听其他的服务请求。 工作模式分类： 独立守护进程（stand-alone daemon）：该守护进程可以独立运行，常驻内存，响应快，无服务启动时间。所有独立守护进程的脚本都在/etc/rc.d/init.d/目录下，由ini脚本负责管理。 超级守护进程（super daemon）：RHEL使用的超级守护进程叫做 xinted（eXtended InterNET Daemon），它能同时监听多个指定的端口，根据用户请求端口的不同，来启动不同的网络服务进程来处理这些用户请求。 和 stand alone工作模式相比，系统不必为每一个网络服务进程监听其服务端口，这样降低了系统开销， 有效利用 系统资源。 但是对于访问量大、经常出现并发时，xinetd 想要频繁启动对应的网络服务进程， 反而会导致系统性能下降。因此，对于负载高服务，比如 Apache、sendmail等服务是单独启动的。 对于 CentOS，在默认情况下，守护进程一般来说都是独立进程， 除非进行过配置，否则 xinted这个超级守护进程是不开机启动的。 运行不必要或有漏洞的守护进程会给操作系统带来安全和性能上的影响。 在 RHEL/CentOS中，服务脚本基上全部放在 /etc/init.d/这个目录下，实际上这些脚本是放在 /etc/rc.d/init.d/ 目录中的， /etc/init.d/是一个符号链接。 脚本的内容大致包括如下内容 ：脚本的描述、环境调用、搜寻配置文件、加载 functions、服 务的启动停止与加载、最后还会有脚本参数。这些脚本都可以直接运行。 systemctl systemctl是systemd下的一个工具，也是CentOS7中控制服务的主要工具，用于替代CentOS 6 中的service和chkconfig两个命令。 systemctl is-enabled .service # 查询服务是否开机启动 systemctl enable .service # 开机运行服务 systemctl disable .service # 取消开机运行 systemctl start .service # 启动服务 systemctl stop .service # 停止服务 systemctl restart .service # 重启服务 systemctl reload .service # 重新加载服务配置文件 systemctl status .service # 查询服务运行状态 systemctl --failed # 显示启动失败的服务 远程管理 SSH所需要的有软件： openssh（核心文件 ） openssh-clients（SSH客户端） openssh-server（SSH 服务器端）：守护进程名为sshd，开机自启动。 SSH的安全配置分为3部分： SSH服务器自身的安全配置 系统防火墙的配置 通过可靠手段向用户公布主机指纹 SSH的配置文件为/etc/ssh/sshd_config，可以通过修改相关配置，来拒绝特定用户联机、主动断开长时间没有动作的客户端，等等。 ssh登陆远程主机：ssh [选项] username@IPAddress -p 指定主机 SSH 端口，如不指定默认为 22 端口。 常用远程连接软件： putty xshell SecureCRT 配置ssh秘钥登陆： 在用户A的家目录下执行命令ssh -keygen -t rsa，生成秘钥（公钥、私钥），位于~/.ssh/目录下。 将公钥内容复制到~/.ssh/authorized_keys文件中。 分发秘钥：在想要登陆到用户A的客户端中（比如用户B），将用户A中生成的私钥放置在用户B的~/.ssh/目录下。通过此私钥，用户B就可以在远程终端上通过SSH客户端以用户A的身份连接到主机。 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-28 20:58:15 "},"centos/linux知识点.html":{"url":"centos/linux知识点.html","title":"linux知识点","keywords":"","body":"Linux知识点 [TOC] Linux常用快捷键 shell执行命令流程 bash bash历史 别名 bash补全 bash脚本 shell元字符 命令中的条件判断 命令组合 控制流程 调试shell程序 xx 一个程序需要从外界获取输入，常见形式如下： 配置文件 环境变量 命令行参数。三者风格： param=value -字母 value --字符串 value 交互式键盘输入 Linux常用快捷键 Tab： 命令补全 文件名或目录名补全 连续按下两次Tab，显示以输入字符开头的所有命令。 Ctrl+d： 结束键盘输入 让用户离开文字界面，相当于输入exit 在命令行中向右删除，相当于按下Del键 Ctrl+c： 结束当前正在运行的程序 取消当前命令行的编辑 Ctrl+l：终端清屏，刷新屏幕 Ctrl+z：将正在运行的程序送到后台。 Ctrl+r：搜索历史命令 Ctrl+a：移动光标到所在行的行首 Ctrl+e：移动光标到所在行的行尾 Ctrl+u：擦除从当前光标位置到行首的全部内容 Ctrl+k：擦除从当前光标位置到行尾的全部内容 Ctrl+w：擦除光标位置前的单词(以空格划分)；如果光标在一个单词本身上，它将擦除从光标位置到该单词词首的全部字母。 Ctrl+y：粘贴使用 Ctrl+w，Ctrl+u 和 Ctrl+k 快捷键擦除的文本。 shell执行命令流程 主要有以下前置工作： 文件名生成： 遵循通配符规则，按照字典序排列。如ls *.c 如果没有找到匹配文件，保持原文。如 ls *.c ls: cannot access *.c: No such file or directory 变量替换：如ls $HOME 命令替换： 使用反引号将命令括起来。如now='date' （反引号不能显示，这里以单引号代替），以命令date的stdout替换date。 （我的机器不支持）使用${}：如 now=${date}，以命令date的标准输出替换${date}。 bash 自动执行的一批命令（用户级别）： 当bash作为注册shell被启动时，会自动执行用户主目录下的 ~/.bash_profile 文件中的命令。 当bash作为注册shell在退出时，会自动执行用户主目录下的 ~/.bash_logout 。 当bash作为交互式shell启动时，会自动执行用户主目录下的 ~/.bashrc 。 自动执行的一批命令（系统级别）： 当bash作为注册shell被启动时，会自动执行用户主目录下的 /etc/profile 文件中的命令。 当bash作为注册shell在退出时，会自动执行用户主目录下的 /etc/logout 。 当bash作为交互式shell启动时，会自动执行用户主目录下的 /etc/bashrc 。 bash历史 历史记录表存储在 ~/.bash_history . 如果想要修改历史记录表的大小，需要在 ~/.bashrc 中修改 HISTSIZE 变量。 浏览历史命令： 直接使用上下方向键 !!：引用上一命令 !str：以str开头的最近用过的命令 Ctrl+r：搜索历史命令 别名 可以为linux命令定制别名（alias）： alias rm='rm -i'：新增别名。可以将其写入到~/.bashrc中。 alias：查看别名表 unalias rm：取消别名 bash补全 Tab键： 每行的首个单词：可以补全搜索 $PATH 下的命令。 行中的其他单词：补全当前目录下的文件名。 bash脚本 变量名： 第一个字符必须是字母、下划线 其余字符可以是字母、数字、下划线 变量赋值：addr=172.31.3.1。等号左右两边不能有空格。 引用变量：$addr 、${addr} 引用未定义的变量，变量值为空字符串。 赋值时，如果等号右侧字符串中有特殊字符，如空格，需要将整个字符串使用双引号括起来。 shell内部开关： set +u 或 set -u ：使用加号时，如果引用了一个未被定义的变量，会被认为是空串（默认情况）。使用减号是，如果引用未定义变量，会产生一个错误。 set +x 或 set -x ：减号表明，执行命令前打印出shell替换后变量后的命令及参数（为了区别正常输出，会在该打印前加上+）。加号则取消上述设置。 变量类型： 局部变量：所创建的shell变量，默认为局部变量。 环境变量：使用export命令可以将局部变量转为环境变量。常见环境变量： LANG：语言选择 HOME：主目录 TERM：终端 类型 PATH：可执行文件的查找路径 CLASSPATH ：类库查找路径 CVSROOT： shell启动的子进程会继承环境变量，不会继承局部变量。 子进程中对环境变量的修改，不影响父进程中的同名变量。 列出当前变量： set：内部命令，列出当前所有变量及其值，以及函数定义。 env：外部命令，列出所有环境变量。 shell内部变量（位置参数）： $0：脚本文件本身的名字。 $1 / $2：1号命令参数，2号命令参数，以此类推 $#：命令行参数的个数，不包括脚本文件名。 \"$*\"：等同于\"$1 $2 $3 ...\" \"$@\"：等同于 \"$1\" \"$2\" \"$3\" ... $?：命令执行后返回的状态 $$：当前进程的进程号 ？%!：后台运行的最后一个进程号 内部命令： shift：位置参数的移位操作，$# 的值减1，旧的$2 变成 $1， 旧的 $3 变成 $2。 shift 3：移动3位 shell元字符 空格、制表符：命令行参数的分隔符 回车：执行键入的命令 <>|：重定向与管道 ;：用于一行内输入多个命令 &：后台运行 $：引用shell变量 反向单引号：用于命令替换 *[]?：文件通配符 \\：取消后继字符的特殊作用（转义）。如果反斜线加在非元字符前面，跟没有一样。 ()：用于定义shell函数，或在子shell中执行一组命令 ()> 等除了它们自身的特殊含义外，还同时起到分隔符的作用 (同空格 ) 元字符： 单引号：对所括起的任何字符，不作特殊解释。系统从扫描到单引号开始，停止对所有字符的特殊解释，直到再次遇到单引号。 双引号：除$ 和反向单引号之外，其他特殊字符的特殊含义被取消 反向单引号：只有自身和反斜线是需要特殊对待的，将反撇号和反斜线再使用反斜线进行转义。 命令中的条件判断 使用 $? 可以获取上一条linux命令的执行情况。0表示正常运行，非0表示出错。 用管道线连接在一起的若干命令 ，进行条件判断时以最后一个命令执行的返回码为准。 复合逻辑： cmd1 && cmd2：若cmd1执行成功（返回0）则执行cmd2，否则不执行。 cmd1 || cmd2：cmd执行失败（返回非0）则执行cmd2，否则不执行cmd2. /bin/true总返回0，/bin/false总返回非0。 test命令：/usr/bin/test ，与 /usr/bin/\\[（该命令必须以]结尾）的效果相同。 test选项： 选项 -f -d -r -w -x -s 含义 普通文件 目录文件 可读 可写 可执行 size>0 字符串比较：[ str1 = str2 ] / [ str1 != str2 ]，注意在方括号、等号周围都有空格。 整数比较： 选项 -eq -ne -gt -ge -lt -le 含义 等于 不等于 大于 大于等于 小于 小于等于 例：test 'ls | wc -l' -ge 100 && echo \"Too many files\"，框住ls命令的是反向单引号。 逻辑运算：! 非、-o或、 -a 与。 例：[ ! -d $cmd -a -x $cmd ] && $cmd 命令组合 { list; }：在当前shell中执行一组命令。 (list)：在子shell中执行一组命令。 左花括号后面必须有一个空格。圆括号是 shell元字符，花括号不是，它作为一个特殊内部命令处理。所以必须是一行的行首单词。 [ -f core ] && { echo \"rm core\" rm core } [ -f core ] && { echo \"rm core\";rm core;} 控制流程 if condition then list # if 不能和 then 合并成一行。除非加分号 elif condition then list else list fi case： case word in pattern1) list1;; # 两个分号是一个整体 pattern2) list2;; ... esac while： while condition do list done until condition do list done for for name in word1 word2 ... do list done for name # 相当于for name in $1 $2 ... do list done for i in `seq 1 10` # 产生1到10 内部命令： break：用于for、while结构，终止循环 continue：结束本轮循环 exit：结束脚本程序的执行，退出。参数为该进程执行结束后的返回码。 函数： name() {list; return 0;} 参数引用： 函数定义完成之后，该函数名作为一个自定义内部命令执行，后面可以调用 调用时函数名后附加0到多个参数，在函数内部以 $1 $1 $* $@ 进行引用。 shell 不支持除字符串以外的数据类型，不支持加减乘等算运和关于字符串的正则表达式运算。 可以借助可执行程序/usr/bin/expr 实现。 有的 shell （包括 bash ）为了提高执行效率，供内部命令版本 echo、printf、expr、echo、 test、[ 等命令，但这仅仅是一种优化措施。只依赖外部命令完全可以实现。 expr命令： 括号 算术运算（5种）：+-*/% 关系运算（6种）：>/>=/ 逻辑运算（2种）：或|、与&。 正则表达式运算：冒号string : pattern，pattern匹配字符串，打印匹配长度。冒号左右有空格 pattern中用 \\(和\\)括起来的一部分，能匹配时打印括号内匹配的部分，否则为空字符串。 调试shell程序 在Shell脚本程序的编写过程中难免会出现这样或那样的错误，错误是在所难免的，主要是要学会快速查找和改正错误。本小节介绍Shell脚本编写过程中的一般错误和程序的调试与跟踪方法。 一般错误： 输入错误：如输入了错误的关键字、成对的符号漏输入一部分等。 字符大小写：在Linux中，对大小写字符是严格区分的，输入时需要注意。所有关键字都是使用小写字母来表示的，建议变量名使用大写字母组合来表示。 循环错误：由于Shell中的循环控制语句与一般高级程序设计语言有所不同，输入结构时容易出错。 调试跟踪： -n：bash命令的“-n”选项使Shell不执行脚本，仅检查脚本中的语法问题。 -v：bash命令的“-v”选项使Shell在执行程序过程中，将读入的每一个命令行都原样输出到终端。 -x：bash命令的“-x”选项使Shell在执行程序过程中，把执行的每一个命令在行首用一个“+”号加上对应的命令显示在终端上，并把每一个变量和该变量的值也显示出来。使用该选项更方便跟踪程序的执行过程。 xx printf '%s\\n' $HOME ： 要使用单引号。 read name：从用户输入中获取一行内容，赋值给变量name。 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-17 09:15:38 "},"centos/其他命令.html":{"url":"centos/其他命令.html","title":"其他命令","keywords":"","body":"其他命令 [TOC] 了解系统状态 vmstat 常用文本处理命令 行筛选 文件比较 目录相关命令 date：查看日期和时间。date \"+%Y-%m-%d %H:%M:%S\" 控制输出格式 time ( 其他命令 )：先执行其他命令，在打印这些命令的时间。 cal：显示日历 cal year cal month year bc：启动一个计算器。 基本计算器功能。 支持变量、函数，条件和循环等编 功能（类似 C语言的小编程) 可以进行任意精度的计算。bc 缺省精度，为小数点后0位。bc -l 精度为小数点后面20位。此外还可以在计算器中通过赋值来改变精度，如 scale=1000 表示保留3位小数。 了解系统状态 who ：确定谁在系统中。列出当前已登录入系统的用户。 who am i ：列出当前终端上登陆的用户 tty：打印出当前终端的设备文件名 whoami：仅列出当前终端上的登陆用户名 uptime：了解系统启动时间和忙碌程度。主要输出如下内容： 系统自启动后到现在的运行时间 当前登录系统的用户数 近期 1分钟， 5分钟， 15 分钟内系统 CPU 的负载 top ：列出资源占用排名靠前的进程 free：了解内存使用情况。常用free -h 命令使输出易读。 Linux为提高效率，利用程序暂时不用的内存，缓冲读写过的磁盘信息。 vmstat：了解系统负载情况 vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 187724 143988 941288 0 0 26 23 0 5 12 1 87 0 0 字段解释： Procs r：等待运行的进程数 b：处在非中断睡眠状态的进程数 Memory free：空闲的内存 buff/cache：用做缓存的内存数 Swap： 磁盘 /内存的交换页数量，单位： KB/ 秒 IO：块设备 I/O 块数，单位：/秒。block in，block out System in：每秒的硬件中断数 （interrupt） ，包括时钟中断 cs : 每秒的环境切换次数（context switch） CPU：CPU的总使用率 us=user，sy =system，id=idle，wa =wait for disk I/O 常用文本处理命令 more/less ：逐屏显示文件 cat 与od ：列出 文件内容 head 与tail：显示文件的头部或者尾 tee ：三通 wc ：对文件进行统计 sort ：对文件内容排序 tr ：翻译字符 uniq：筛选文件中的重复行 行筛选 grep/egrep/fgrep:在文件中查找字符串（筛选） sed：流编辑（加工） awk：逐行扫描进文本处理的一门语言（筛选与加工） 文件比较 cmp 和散列算法：判断两个文件内容是否相同 文件数据完整性验证：md5sum/sha1sum diff ：列出两个文本件之间的区别 版本管理 目录相关命令 pwd：print working dictionary cd：切换目录。cd是shell的一个内部命令 mkdir rmdir touch： 创建文件 将文件的最后一次修改时间设置为当前，但不修改文件内容。 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-17 09:15:38 "},"centos/问题集合.html":{"url":"centos/问题集合.html","title":"问题集合","keywords":"","body":"问题集合 [toc] 中文乱码 中文乱码 可以改变以下2个变量： export LANG=\"en_US.UTF-8\" export LC_ALL=\"en_US.UTF-8\" # locale_all Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-28 20:40:37 "},"github/git命令.html":{"url":"github/git命令.html","title":"git命令","keywords":"","body":"git 命令 [TOC] 远程分支 fetch pull push pull 与 push 一些小技巧 .gitignore文件不起作用 git commit之后想撤销 commit注释写错 将当前分支上修改的东西转移到新建分支 参考：http://try.github.io/ commit命令保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多。 # 提交记录不是挂在当前节点下，而是挂在当前节点的父节点下，即当前节点与提交节点是兄弟关系 git commit --amend git branch bugFix # 创建分支 git checkout bugFix # 切换分支 # 两句变一句 git checkout -b bugFix git merge bugFix # 将分支bugFix合并到当前分支上 Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。 # 将当前分支的提交在master基础上再重新提交一遍，当前分支移动到提交后的节点上。 git rebase master # 把当前分支复制到master分支上（复制的是2者之间不同的节点） # git rebase master [current_branch] # 在前一个分支上，将后一个分支上的内容复制过去 git rebase bugFix master # 将master复制到到bugFix上。 rebase优点：Rebase 使你的提交树变得很干净, 所有的提交都在一条线上。 rebase缺点：Rebase 修改了提交树的历史。 分离HEAD git checkout c2 # c2 是一个节点的hash值 cat .git/HEAD # 查看HEAD的指向 git symbolic-ref HEAD # 如果 HEAD 指向的是一个引用，使用该命令查看它的指向 使用节点的hash值不方便，因此可以使用分支名的相对引用： 使用 ^ 向上移动 1 个提交记录。 使用 ~ 向上移动多个提交记录，如 ~3。 git checkout master^ # 将HEAD切换到master的父节点 git checkout HEAD^ # 将HEAD切换到当前HEAD的父节点 操作符 ^ 后面也可以跟一个数字，用于指定合并提交记录中的某个父提交。Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。 # 假定当前master是merge得到的，即当前master有2个父提交 git checkout master^ # HEAD 切换到master的第一个父提交 git checkout master^2 # HEAD 切换到master的第二个父提交 # 支持链式操作 git checkout HEAD~^2~2 # 先到父节点，在到第二个父节点，再到祖节点 -f 允许许我们将分支强制移动到某个位置。 git branch -f master HEAD~3 # 强制移动分支master到HEAD的 3 级父提交节点。 主要有两种方法用来撤销变更： git reset、 git revert。 git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。但是这种“改写历史”的方法对大家一起使用的远程分支是无效的。 git revert用于需要对远程仓库进行撤销的操作。 git reset HEAD~1 # 将当前分支会回退到上一次提交。 git revert HEAD # 通过新增操作来抵消HEAD节点的增删改，会在HEAD后再新增一个节点。 将一些提交复制到当前所在的位置（HEAD）下面： git cherry-pick ... 如果不清楚想要的提交记录的哈希值时，可以使用交互式的 rebase命令实现cherry-pick功能。 交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i。 可以做3件事： 调整提交记录的顺序。 删除你不想要的提交。 合并提交。允许你把多个提交记录合并成一个。 git rebase -i HEAD^4 # 从当前HEAD开始往上算，第5个节点处会重新生出一条分支，将前4个节点重新排列或删除。 git rebase -i master # 将从HEAD到master（不包含master）的节点重新排列提交，在master下生出新分支。 git tag 可以（在某种程度上，因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。 git tag tag1 c1 # c1节点上打上标签tag1 git tag tag2 # 在当前HEAD节点上打上标签tag2 由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe。 Git Describe 能帮你在提交历史中移动了多次以后找到方向。 git describe # 可以是任何能被 Git 识别成提交记录的引用。不指定时为HEAD。 # 输出结果 # __g # tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。 # 当 ref 提交记录上有某个标签时，则只输出标签名称 远程分支 本地仓库会有一个名为 o/master 的分支, 这种类型的分支就叫远程分支。由于远程分支的特性导致其拥有一些特殊属性。 远程分支反映了远程仓库（在你上次和它通信时）的状态。这会有助于你理解本地的工作与公共工作的差别， 这是你与别人分享工作成果前至关重要的一步. 远程分支有一个特别的属性，在你checkout操作时会自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。 远程分支有一个命名规范：/ 如果你看到一个名为 o/master 的分支，那么这个分支就叫 master，远程仓库的名称就是 o 大多数的开发人员会将它们主要的远程仓库命名为 origin，并不是 o。这是因为当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了。 o/master 只有在远程仓库中相应的分支更新了以后才会更新。 fetch 从远程仓库获取数据：git fetch。可以将 git fetch 的理解为单纯的下载操作。 git fetch 完成了仅有的但是很重要的两步： 从远程仓库下载本地仓库中缺失的提交记录。 更新远程分支指针（如 o/master）。 git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件。 pull git pull 等价于下面两条命令： git fetch git merge o/master # 如果还有其他分支，继续合并。 push 与 git pull 相反的命令是git push。 git push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了。 注：git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。 当远程分支有更新时，此时git push会有冲突，使用如下方法解决： git fetch git rebase o/master # 或者 git merge o/master git push git pull --rebase # fetch 和 rebase 的简写。 pull 与 push 本地与远程之间的关联： pull 操作时, 提交记录会被先下载到 o/master 上，之后再合并到本地的 master 分支。隐含的合并目标由这个关联确定的。 push 操作时, 我们把工作从 master 推到远程仓库中的 master 分支(同时会更新远程分支 o/master) 。这个推送的目的地也是由这种关联确定的。 master 和 o/master 的关联关系就是由分支的“remote tracking”属性决定的。master 被设定为跟踪 o/master —— 这意味着为 master 分支指定了推送的目的地以及拉取后合并的目标。 有两种方法设置这个属性： 第一种就是通过远程分支checkout出一个新的分支，执行git checkout -b totallyNotMaster o/master，就可以创建一个名为 totallyNotMaster 的分支，它跟踪远程分支 o/master。 git branch -u o/master foo ，这样 foo 就会跟踪 o/master 了。如果当前就在 foo 分支上, 还可以省略 foo。 push语法： git push git push origin : ： 将本地的source分支推送到远程的destination分支。 如果要推送到的目的分支不存在，Git 会在远程仓库中根据你提供的名称帮你创建这个分支。 # 切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去。 git push origin master # 通过“place”参数来告诉 Git 提交记录来自于 master, 要推送到远程仓库中的 master。它实际就是要同步的两个仓库的位置。 git fetch 的参数和 git push 极其相似。他们的概念是相同的，只是方向相反罢了。 git fetch origin foo # Git会到远程仓库的foo分支上，获取所有本地不存在的提交，放到本地的 o/foo 上。 如果 git fetch 没有参数，它会下载所有的提交记录到各个本地的远程分支。 省略参数： git push origin :side：删除远程仓库中的 side 分支，相当于将null推送到了远程的side分支。 git fetch origin :bugFix：会在本地创建一个新分支bugFix。 pull： git pull origin foo 相当于git fetch origin foo; git merge o/foo。 git pull origin bar~1:bugFix 相当于git fetch origin bar~1:bugFix; git merge bugFix 一些小技巧 .gitignore文件不起作用 在开发过程中，在 .gitignore中添加了一些忽略 项，但仍会被提交。 原因：新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。 命令如下： git rm -r --cached . # -r是递归删除， --cache只从索引中删除，不删除本地文件 git add . git commit -m 'update .gitignore' git commit之后想撤销 git reset --soft HEAD^ # --soft表示只重置HEAD，--hard则重置HEAD，索引，工作树 仅仅是撤回commit操作，写的代码仍然保留。 不删除工作空间改动代码，撤销commit，不撤销git add . commit注释写错 只是想改一下注释，只需要： git commit --amend 将当前分支上修改的东西转移到新建分支 比如我在A分支做了一些修改，现在由于某种原因(如A分支已经合并到master)，不能把A分支上修改的东西保留下来但是需要把A分支上修改的东西继续在新分支继续修改。那么现在我们可以有两种简单的做法完成这一需求。 我们不需要在A分支做commit，只需要在A分支新建B分支，然后切换过去。这个时候你会发现修改的东西在A，B分支都有。这个时候在B分支commit，那么这些修改保留在B分支上，再切换到A分支上会发现修改都没有保留下来。 使用git stash 将A分支暂存起来，然后在某一个分支（如master分支）新建一个分支B，然后在B分支上使用 git stash pop 将修改弹出到B分支上，然后这些修改就在B分支上了。 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-28 21:10:02 "},"github/项目介绍.html":{"url":"github/项目介绍.html","title":"项目介绍","keywords":"","body":"项目介绍 [TOC] scrapydweb pyecharts gitbook 一些我感兴趣的github项目介绍。 scrapydweb https://github.com/my8100/scrapydweb 项目演示：scrapydweb.herokuapp.com 用于 Scrapyd 集群管理的 web 应用，支持 Scrapy 日志分析和可视化。 pyecharts https://github.com/pyecharts/pyecharts API文档：https://pyecharts.org/#/zh-cn/intro 线上渲染展示：https://gallery.pyecharts.org/#/README Echarts 是一个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是一门富有表达力的语言，很适合用于数据处理。当数据分析遇上数据可视化时，pyecharts诞生了。 gitbook 中文介绍：http://gitbook.zhangjikai.com/ Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-17 09:15:38 "},"nodejs/NodeJS.html":{"url":"nodejs/NodeJS.html","title":"nodejs","keywords":"","body":"NodeJS [TOC] Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境。Node.js 由 Node.js 基金会持有和维护，并与 Linux 基金会有合作关系。Node.js 采用 Google 开发的 V8 运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。 Node.js 大部分基本模块都用 JavaScript 语言编写。在 Node.js 出现之前，JavaScript 通常作为客户端程序设计语言使用，以 JavaScript 写出的程序常在用户的浏览器上运行。Node.js 的出现使 JavaScript 也能用于服务端编程。Node.js 含有一系列内置模块，使得程序可以脱离 Apache HTTP Server 或 IIS，作为独立服务器运行。 Node.js 特点 它是一个 JavaScript 运行环境。 依赖于 Chrome V8 引擎进行代码解释。 事件驱动：在 Node.js 中，客户端请求建立连接，提交数据等行为，会触发相应的事件。Node.js 在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数。 非阻塞 I/O：Node.js 中采用了非阻塞型 I/O 机制，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。 轻量可伸缩，适用于实时数据交互应用。 单线程：好处是减少内存开销，不用像多线程编程那样处处在意状态同步的问题。缺点是错误会引起整个应用的退出。 Node.js 适用场景 我们从 Node.js 的特点中可以知道 Node.js 擅长处理 I/O，不善于计算（单线程的缺点），因此 Node.js 适用于：当应用程序需要处理大量并发的 I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js 也非常适合与 Web socket 配合，开发长连接的实时交互应用程序。比如：聊天室，博客系统，考试系统等。 NPM 介绍 NPM 是随同 Node.js 一起安装的包管理工具。因此当我们安装好 Node.js 的时候，也安装好了 NPM。NPM 是一个命令行工具，用于从 NPM Registry 中下载、安装 Node.js 程序，同时解决依赖问题。 PEPL Node.js REPL（Read Eval Print Loop：交互式解释器）表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。我们可以用来执行 JavaScript 代码。 _：上一个表达式的运算结果 REPL 常用命令 Ctrl + C - 退出当前终端。 Ctrl + C - 连续按两次退出 Node REPL。 Ctrl + D - 退出 Node REPL。 向上/向下键 - 查看输入的历史命令。 变量 在 JavaScript 中全局对象通常是 window，而在 Node.js 中全局对象是 global。所有全局变量（除了 global 本身以外）都是 global 对象的属性，我们可以直接访问到 global 的属性。 按照 ECMAScript 的定义，满足以下条件的变量是全局变量： 在最外层定义的变量。 全局对象的属性。 隐式定义的变量（未定义直接赋值的变量）。 注：当你定义一个全局变量的时候，这个变量同时也会成为全局对象的属性，反之亦然。在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。定义变量一定要使用 var 关键字，因为全局变量会污染命名空间。 常用的全局变量和全局函数： __filename ：表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。 __dirname ：表示当前执行脚本所在的目录。 setTimeout(callback, ms) ：全局函数在指定的毫秒（ms）数后执行指定函数（callback），只执行一次函数。 clearTimeout(t) ：用于停止一个之前通过 setTimeout() 创建的定时器。参数 t 是通过 setTimeout() 函数创建的定时器。 setInterval(cb, ms) ：与 setTimeout(cb, ms) 类似，不同的是这个方法会不停的执行函数。直到 clearInterval() 被调用或窗口被关闭，也可以按 Ctrl + C 停止。 console.log() ：是个全局函数用于进行标准输出流的输出，即在控制台中显示一行字符串，和 JavaScript 中的使用一样。 xx Node.js 应用组成： 引入 required 模块：使用 required 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache、Nginx 等 HTTP 服务器。 接受请求与响应请求。 Node.js 包 包用于管理多个模块及其依赖关系，可以对多个模块进行封装，包的根目录必须包含 package.json 文件。package.json 文件是 CommonJS 规范用于描述包的文件，符合 CommonJS 规范的 package.json 文件一般包含以下字段： name：包名。包名是唯一的，只能包含小写字母、数字和下划线。 version：包版本号。 description：包说明。 keywords：关键字数组，用于搜索。 homepage：项目主页。 bugs：提交 bug 的地址。 license：许可证。 maintainers：维护者数组。 contributors：贡献者数组。 repositories：项目仓库托管地址数组。 dependencies：包依赖。 通过命令 npm install/update/uninstall xxx 来安装、更新、卸载包。 Node.js 模块 在 JavaScript 中，我们通常把 JavaScript 代码分为几个 js 文件，然后在浏览器中将这些 js 文件合并运行，但是在 Node.js 中，是通过以模块为单位来划分所有功能的。每一个模块为一个 js 文件，每一个模块中定义的全局变量和函数的作用范围也被限定在这个模块之内，只有使用 exports 对象才能传递到外部使用。Node.js 官方提供了很多模块，这些模块分别实现了一种功能，如操作文件及文件系统的模块 fs，构建 http 服务的模块 http，处理文件路径的模块 path 等。当然我们也可以自己编写模块。 自定义模块示例： // myModule.js function foo() { console.log(\"hello syl\"); } module.exports.foo = foo; // module.exports 导出foo，供其他模块使用。 每次导出接口成员的时候都通过module.exports.xxx = xxx 的方式很麻烦，点儿的太多了。所以，Node.js 为了简化操作，专门提供了一个变量：exports 等于 module.exports。 在其他模块中引用： // index.js var hello = require(\"./myModule.js\"); hello.foo(); require() 得到的是 module.exports 导出的值，导出多个成员可以用 module.exports 和 exports，导出单个成员只能用 module.exports。 注：require() 加载模块，以 / 为前缀的模块是文件的绝对路径。./ 为前缀的模块是相对于调用 require() 的文件的。 当没有以 /、./ 或 ../ 开头来表示文件时，这个模块必须是一个核心模块或加载自 node_modules 目录。如果给定的路径不存在，则 require() 会抛出一个 code 属性为 'MODULE_NOT_FOUND' 的 Error。 核心模块定义在 Node.js 源代码的 lib/ 目录下。require() 总是会优先加载核心模块。例如：require('http') 始终返回内置的 HTTP 模块，即使有同名文件。 常用模块 http： 该模块主要用于搭建 HTTP 服务端和客户端，要使用 HTTP 服务器和客户端功能必须调用 http 模块。 util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。 const util = require('util'); fs ： 该模块供了一个 API，用于以接近标准 POSIX 函数的方式与文件系统进行交互。 var fs = require(\"fs\"); fs.readFile(\"./index.html\", function(err, data) { if (err) { console.log(\"文件读取失败，请稍后重试！\"); } else { // data 默认是二进制数据，可以通过 .toString 转为咱们能识别的字符串 } }); 所有文件系统操作都具有同步和异步的形式。异步方法中回调函数的第一个参数总是留给异常参数（exception），如果方法成功完成，那么这个参数为 null 或者 undefined。 fs.open(path, flags[, mode], callback);： path：文件的路径 flags：文件打开的行为。 a：打开文件用于追加。如果文件不存在，则创建该文件。 ax：与 a 相似，但如果路径存在则失败。 a+：打开文件用于读取和追加。如果文件不存在，则创建该文件。 ax+：与 a+ 相似，但如果路径存在则失败。 as：以同步模式打开文件用于追加。如果文件不存在，则创建该文件。 as+：以同步模式打开文件用于读取和追加。如果文件不存在，则创建该文件。 r：打开文件用于读取。如果文件不存在，则会发生异常。 r+：打开文件用于读取和写入。如果文件不存在，则会发生异常。 rs+：以同步模式打开文件用于读取和写入。指示操作系统绕开本地文件系统缓存。这对于在 NFS 挂载上打开文件非常有用，因为它允许跳过可能过时的本地缓存。它对 I/O 性能有非常实际的影响，因此除非需要，否则不建议使用此标志。这不会将 fs.open() 或 fsPromises.open() * 转换为同步的阻塞调用。如果需要同步操作，则应使用 fs.openSync() 之类的操作。 w：打开文件用于写入。创建文件（如果它不存在）或截断文件（如果存在）。 wx：与 w 相似，但如果路径存在则失败。 w+：打开文件用于读取和写入。创建文件（如果它不存在）或截断文件（如果存在）。 wx+：与 w+ 相似，但如果路径存在则失败。 mode：设置文件模式(权限)，文件创建默认权限为 0o666（可读写）。mode 设置文件模式（权限和粘滞位），但仅限于创建文件的情况。在 Windows 上，只能操作写权限。 callback：回调函数，带有两个参数如：callback(err, fd)。 fs.openSync(path, flags[, mode])：同步打开文件，参数和用法参照异步 fs.open()。在 Node.js 中我们大多是用异步的方式。 fs.close(fd, callback);： fd：通过 fs.open() 方法返回的文件描述符。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 使用 fs.read() 和 fs.write() 读写文件需要使用 fs.open() 打开文件和 fs.close() 关闭文件。 异步读取文件的语法格式为： fs.read(fd, buffer, offset, length, position, callback); 参数说明： fd：通过 fs.open() 方法返回的文件描述符。 buffer：是数据写入的缓冲区。 offset：是缓冲区中开始写入的偏移量。一般它的值我们写为 0。 length：是一个整数，指定要读取的字节数。 position：指定从文件中开始读取的位置。如果 position 为 null，则从当前文件位置读取数据，并更新文件位置。 callback：回调函数，有三个参数 (err, bytesRead, buffer)。err 为错误信息，bytesRead 表示读取的字节数，buffer 为缓冲区对象。 异步写入文件的语法格式为： fs.write(fd, buffer, offset, length, position, callback); 参数说明： fd：从指定的文件写入数据。 buffer：是数据写入的缓冲区。 offset：指定要写入的 buffer 部分。 length：是一个整数，指定要写入的字节数。 position 指定应该写入此数据的文件开头的偏移量。如果 typeof position !== 'number'，则从当前位置写入数据。 callback：回调有三个参数 (err, bytesWritten, buffer)，其中 bytesWritten 指定从 buffer 写入的字节数。 fs.write(fd, string[, position[, encoding]], callback); 参数说明： fd：从指定的文件写入数据。 string：写入的数据，如果不是字符串，则该值将被强制转换为字符串。 position 指定应该写入此数据的文件开头的偏移量。如果 typeof position !== 'number'，则从当前位置写入数据。 encoding：指定字符串的编码，默认为 'utf8'。 callback：回调有三个参数 (err, written, string)，其中 written 指定字符串中已写入文件的字节数。写入的字节数与字符串的字符数是不同的。 异步读取文件的语法格式为： fs.readFile(path, [options], callback); 参数说明： path：文件名或文件描述符。 options：该参数是一个对象，包含 {encoding, flag}。encoding 默认值为 null，flag 默认值为 'r'。 callback：回调函数。 异步写入文件的语法格式为： fs.writeFile(file, data, [options], callback); 参数说明： file：文件名或文件描述符。 data：要写入文件的数据，可以是 String（字符串）或 Buffer（缓冲）对象。 options：该参数是一个对象，包含 {encoding, mode, flag}。encoding 默认值为：'utf8'，mode 默认值为 0o666，flag 默认为 'w'。 callback：回调函数。 异步获取文件信息的格式为： fs.stat(path, callback); 参数说明： path：文件路径。 callback：回调函数，带有两个参数如：(err, stats)，stats 是 fs.Stats 对象。如果出现错误，则 err.code 将是常见系统错误之一。 不建议在调用 fs.open()、fs.readFile() 或 fs.writeFile() 之前使用 fs.stat() 检查文件是否存在。而是，应该直接打开、读取或写入文件，并在文件不可用时处理引发的错误。 异步删除文件的语法格式为： fs.unlink(path, callback); 参数说明： path：文件路径。 callback: 除了可能的异常，完成回调没有其他参数。 异步的修改文件名的语法为： fs.rename(oldPath, newPath, callback); 参数说明： oldPath：原来的文件名字。 newPath：新的文件名字。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 异步创建目录的语法为： fs.mkdir(path[, options], callback); 参数说明： path：文件路径。 options：有两个参数。recursive 表示是否以递归的方式创建目录，默认为 false。mode 设置目录权限，Windows 上不支持。默认为 0o777。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 异步读取目录的语法为： fs.readdir(path[, options], callback); 参数说明： path：文件路径。 options：有两个参数 (encoding，withFileTypes)。encoding 默认值为 'utf8'，withFileTypes 默认值为 false。 callback：回调函数，回调函数带有两个参数 (err, files)。err 为错误信息，files 为目录下的文件数组列表。 异步删除目录的语法为： fs.rmdir(path, callback); 参数说明： path：文件路径。 callback：回调函数，除了可能的异常，完成回调没有其他参数。 函数 在 JavaScript 中，一个函数可以作为另一个函数的参数。 function xxx(arg1, arg2){ xxx } 匿名函数就是没有命名的函数。语法为：function(){ xxx } ES6 标准新增了一种箭头函数，该函数表达式的语法比函数表达式更短，并且没有自己的 this，arguments，super 或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。 (arg1, arg2, ... , argN) => {函数声明} // 相当于：(arg1, arg2, ... , argN) => {return 表达式;} (arg1, arg2, ... , argN) => 表达式（单一） // 当只有一个参数时，圆括号是可选的 (arg) => {函数声明} arg => {函数声明} // 没有参数的函数应该写成一对圆括号 () => {函数声明} 回调函数：Node.js 异步编程的直接体现就是回调。回调函数在完成任务后就会被调用，Node.js 使用了大量的回调函数，Node.js 所有 API 都支持回调函数。回调函数一般作为函数的最后一个参数出现。 事件 大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）。比如：fs.readStream 打开文件时会发出一个事件。 可以通过 require(\"events\"); 获得 event 模块。通常，事件名采用“小驼峰式”（即第一个单词全小写，后面的单词首字母大写，其它字母小写）命名方式。 所有能触发事件的对象都是 EventEmitter 类的实例。这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上。当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。 参数说明： eventName：事件名称，string 类型。 listener：回调函数。 args：传递的参数，多个，类型为任意。 EventEmitter 类的实例emitter： addListener(eventName, listener) 或 on(eventName, listener) ：为指定事件注册一个监听器。添加 listener 函数到名为 eventName 的事件的监听器数组的末尾。不会检查 listener 是否已被添加。多次调用并传入相同的 eventName 与 listener 会导致 listener 会被添加多次。 prependListener()：用于将事件监听器添加到监听器数组的开头。默认情况下，事件监听器会按照添加的顺序依次调用。 once(eventName, listener) ：可以注册最多可调用一次的监听器。当事件被触发时，监听器会被注销，然后再调用。 emit(eventName[, ...args]) ：按照监听器注册的顺序，同步地调用每个注册到名为 eventName 的事件的监听器，并传入提供的参数。如果事件有注册监听返回 true，否则返回 false。 removeListener(eventName, listener) 或 off(eventName, listener)：移除监听器。最多只会从监听器数组中移除一个监听器。我们可以多次调用该方法来一个个的移除我们需要移除掉的监听器。 removeAllListeners([eventName]) 移除全部监听器或指定的 eventName 事件的监听器。 setMaxListeners(n) ：设置同一事件的监听器最大绑定数。默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告，这有助于我们发现内存泄露。显然实际编码中并不是所有的事件都要限制 10 个监听器。当值设为 Infinity（或 0）表示不限制监听器的数量。 listenerCount(eventName) ：查看事件绑定的监听器个数。 一旦事件被触发，所有绑定到该事件的监听器都会按顺序依次调用。也就是说在事件触发之后、且最后一个监听器执行完成之前，removeListener() 或 removeAllListeners() 不会从 emit() 中移除它们。 当 EventEmitter 实例出错时，应该触发 'error' 事件。如果没有为error事件注册监听器，则当error 事件触发时，会抛出错误、打印堆栈跟踪、并退出 Node.js 进程。 Web 框架：Express Express 是一个高度包容，快速而极简的 Node.js Web 框架，提供了一系列强大特性帮助我们创建各种 Web 应用，和丰富的 HTTP 工具。我们可以通过 Express 可以快速地搭建一个完整功能的网站。使用框架的目的就是让我们更加专注于业务，而不是底层细节。 安装：npm install express var express = require(\"express\"); var app = express(); // app.post app.get(\"/\", function(req, res) { res.send(\"Hello World\"); }); app.listen(8080, function() { console.log(\"服务器启动了\"); }); 路由用于确定应用程序如何响应客户端请求，包含一个 URI（路径）和一个特定的 HTTP 请求方法（GET、POST 等）。 每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。 路由定义采用以下结构： app.method(path, handler); 注：app 是 Express 的实例，method 是指 HTTP 请求方法（GET、POST 等），path 是指服务器上的路径，handler 是指路由匹配时执行的函数。 Express 提供了内置的中间件 express.static 来设置静态文件如：图片，CSS，JavaScript 等。比如： // 我们只有公开了 public 目录，才可以直接通过 /public/xx 的方式访问 public 目录中的资源 app.use(\"/public/\", express.static(\"./public/\")); Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-17 09:15:38 "},"other/vscode.html":{"url":"other/vscode.html","title":"vscode","keywords":"","body":"VS Code [TOC] 面板命令 命令板 光标操作 多光标编辑 文本编辑 IntelliSense linting（代码静态检查） 重命名 Formatting 折叠 源文件浏览（Go to References） git 其他 关于code的命令行 单元测试 调试 集成调试 插件 VS Code 的定位是编辑器，而非IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。 VS Code 自带了 TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。 面板命令 左边： Ctrl+ Shift+E：打开Explorer Ctrl+ Shift+F：搜索所有文件 Ctrl+ Shift+ G：打开源代码管理（git） CtrI+ Shift+ D：打开Debug Ctrl+ Shift+X：打开扩展 extension 下面： Ctrl+J：快速打开/关闭下方的Panel CtrI+ Shift+ M：打开\"errors and warnings\"窗口。message。按第二次可以关闭 CtrI+ Shift+ U：打开Output窗口。按第二次可以关闭 Ctrl+Shift+ P 或 F1：打开仪表盘，可以搜索所有命令 Ctrl + `：打开terminal。按第二次可以关闭 Ctrl+B：打开/关闭左边的文件导航（sidebar）。隐藏/显示侧边栏 文件跳转： Ctrl+\\：split editor。按 Ctrl+1/2/3进行跳转 Ctrl+F4 ：关闭当前打开的文件 Ctrl+Tab：显示当前打开的所有文件。按tab 进行选择 Alt+←/→：选择前/后一个文件 命令板 Ctrl+P：键入文件名，会快速打开某个文件 直接输入文件名，跳转到文件 键入文件名后，按→ 键，会打开相应文件，但不退出命令板，可以继续打开其他文件 ?：列出当前可执行的命令。命令后面跟一个空格，则会进入下一级。如键入term+space，就会出现一个下拉列表，包含所有terminal名字。 @：显示所有symbol。 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @:：分类显示symbol :：跳到某行。可以使用Ctrl+G快速打开 ? # 根据名字查找 symbol，也可以 Ctrl+T Ctrl+R：快速打开最近打开过的文件夹或workspace 光标操作 Ctrl+Home ： 光标移到文件开头 Ctrl+End：光标移到文件结尾。 Ctrl+U：光标退回上一个位置。 多光标编辑 Shift + ←/↑/→/↓ : 选择块 Shift+Alt + 光标选择：选择方块内容，会在方块的每一行中都有一个光标 Ctrl+Alt + ↑/↓ : 在上/下一行添加光标 Ctrl+Shift+L：选择所有的单词（当前光标所处的单词），在单词后添加光标 Ctrl+F2 : Change all Occurrences Ctrl+Shift+L : Select All Occurrences of Find Match Ctrl+D：选中当前光标处的单词，再按一次，则选中下一个相同的单词 多光标：按住Alt键，然后在页面中希望中现光标的位置点击鼠标。 Alt + Shift + i：在选中的文本的每一行的末尾都创建一个光标。 文本编辑 Ctrl+Shift+K：删除当前行。 Ctrl + Enter：在当前行下面新增一行然后跳至该行。 Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行。 Alt+↑↓：将当前行向上/下移动。 Ctrl+C：复制选中内容或者复制当前行 Ctrl+X：切剪选中内容或者当前行 Ctrl+F：查找。光标定位不在搜索框时，使用F3进行上下查找 Ctrl+Shift+F：文件夹中查找（在多个文件中查找字符串） Ctrl+H：替换 Ctrl+/：行注释 Shift+Alt+A：块注释 Shift+Alt+↑/↓：复制当前行到上/下一行 Ctrl+Shift+K：删除当前行 Ctrl+C：复制当前行，或复制选中内容 Ctrl+X：切剪当前行，或切剪选中内容。可以当作删除当前行来用 Alt+↑/↓：移动当前行到上/下一行 IntelliSense VS Code 为当前工作文件夹中的所有文件，以及安装在标准位置的 Python 包提供了代码补全和智能提示 。 VS Code 收集代码的范围是基于当前工作区文件夹，和settings.json 中的 python.pythonPath 参数而定的。 如果引用的项目既不在工作区内，也不在 Python 库文件夹里，VS Code 无法知道它在哪。这时候需要提供额外的路径去搜寻代码，如下： # .vscode\\settings.json { \"python.autoComplete.extraPaths\": [\"any/path\"], } Ctrl+Space：代码提示，因为热键冲突，将其改为了 Alt+/ linting（代码静态检查） 代码分析工具（pep8、flake8、pylint） VS Code 默认的静态检查工具是 pylint 。 官方的默认配置： { \"python.linting.pylintPath\": \"global/path/to/pylint\", \"python.linting.pylintArgs\": [ \"--disable=all\", \"--enable=F,E,unreachable,duplicate-key,unnecessary-semicolon,global-variable-not-assigned,unused-variable,binary-op-exception,bad-format-string,anomalous-backslash-in-string,bad-open-mode\", ], } 注：可以使用单词描述，也是用使用代号，如E0401。 python.linting.pylintPath 的作用是指定 pylint 的路径，如果不填则默认使用当前工作区指定的 Python 环境中的 pylint。如果虚拟环境多的话，每一个环境中都要安装一遍 pylint，很麻烦，可以全局使用同一个 pylint。 使用全局 pylint 有一点需要注意，因为不同环境中安装的包不一样，必须在静态检查是引入相关的环境下的包，在 --init-hook中把虚拟环境下第三方包的路径导入sys.path即可。 { \"python.linting.pylintArgs\": [ \"--init-hook\", \"import sys; sys.path.insert(0, './modules'); sys.path.extend(['${workspaceFolder}/venv/Lib/site-packages',]); \", ] } 重命名 F2：重命名某个symbol。注，先把光标放到要重命名的symbol上，跟它相关的symbol会闪烁。 Ctrl+F2：重命名当前光标所在的单词（全文替换）。 类似 Ctrl+H替换 Formatting 自动格式化代码。目前支持 autopep8、black 和 yapf。 常用的是 autopep8： # .vscode/settings.json { \"python.formatting.autopep8Path\": \"/path/to/Python/Scripts/autopep8\", } Shift+Alt+F：重新组织代码，也可以使用右键进行选择 Ctrl+K Ctrl+F：只对当前选中部分（current selection）起作用 折叠 Ctrl+Shift+[/]：折叠/展开当前块 Ctrl+K Ctrl+[/]：递归折叠/展开当前块 Ctrl+K Ctrl+0/J：折叠/展开整个文件中的所有块 源文件浏览（Go to References） Ctrl+鼠标单击 或 F12：快速跳转到源文件 Alt+F12：打开一个peek，不跳转到源文件 Shift+F12：打开一个peek，查看源文件的所有引用 Shift+Alt+F12：在左边的sidebar显示所有symbol的引用 git F7 / Shift+F7 ：进入单文件diff，按 Enter重新回到双文件diff。 其他 按住Alt ，然后滚动，可以比直接滚动更快。 Shift+Alt+←/→：Shrink / expand selection。扩大/缩小选择范围 Ctrl+K Ctrl+X：快速去除不必要的空格。只能去除行尾的 Ctrl+D：选中光标所在的单词 排序import语句：右键选择“排序import语句” 提取方法/变量需要安装Python库 rope 关于code的命令行 # open code with current directory code . # open the current directory in the most recently used code window code -r . # create a new window code -n # change the language code --locale=es # open diff editor code --diff # open file at specific line and column code --goto package.json:10:5 # see help options code --help # disable all extensions code --disable-extensions . 单元测试 VS Code 还支持单元测试框架 pytest、unittest 和 nosetest。 调试 tasks.json：Task Runner launch.json：debugger 编辑如下所示的 tasks.json 文件，创建新任务来运行 Flask 开发服务： { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Run Debug Server\", \"type\": \"shell\", \"command\": \"${workspaceRoot}/.venv/bin/flask run -h 0.0.0.0 -p 5000\", \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } Flask 开发服务使用环境变量来获取应用程序的入口点。 如 使用环境变量 一节所说，可以在 .env 文件中声明这些变量： FLASK_APP=wsgi.py FLASK_DEBUG=True 这样就可以使用快捷键 Ctrl + Shift + B 来执行任务了。 集成调试 修改lanuch.json \"name\": 该调试显示的名称； \"type\": 调试类型； \"program\": \"consolo\": \"internalConsole\" 在vscode的“调试控制台”中输出结果， \"integratedTerminal\" 在vscode 集成的terminal 中输出结果；（在调试时，推荐\"internalConsole\" ，下面会具体讲到）； \"pythonPath\": Python解释器的位置； \"request\": 必填项，有两种类型，分别是launch和attach，前者的意思就是 VSCode 会打开这个程序然后进入调试，后者的意思是。。。（用不到，还没用过，我也不会。。） \"args\": 一些（自定义）的参数。 ${file} - the current opened file ； ${workspaceFolder} - the path of the folder opened in VS Code ； 插件 Python Docstring Generator : Python注释自动生成：Ctrl+Shift+2 vscode-icons： 这是一个美化VS Code图标的插件。 git插件： GitLens Git History Git Graph 更强大的自动补全 搜索Kite。然后需要安装一个叫 Kite Engine 的软件，直接前往官网下载对应的系统版本即可： TabNine 基于GPT-2语言模型的自动补全工具。 传统的补全工具更多的是根据上下文信息和第三方库进行补全，换句话说就是基于既有的内容进行补全。而TabNine更多的是偏向推理，它能够根据开发者前面输入的内容快速推理接下来要输入的代码，甚至参数、字符串、符号它都能够准确的推理并补全。 Bookmarks 我们能够使用Ctrl+Alt+K、Ctrl+Alt+J、Ctrl+Alt+L快捷键添加标签，并且可以快速调整到指定标签位置。 TODO Highlight 我们在开发过程中，有时会为了测试或某种原因，某段代码需要之后进行修改和完善。如果就不做一些标记，时间久了、需要修改的多了，就很难区分出哪些是需要修改的、哪些是不需要修改的。因此养成做标记的好习惯对提升开发效率具有很大的帮助。 Code Runner 这是一款支持C、C++、Java、Python等主流编程语言快速运行的插件，它能够便捷的运行当前活动页代码文件、能够运行选定代码段、运行自定义命令，对于调试代码具有很大的帮助。 文件及文件夹图标 默认的VSCode图标没有那么详细，只有几个重要文件类型的图标提示，可以安装vscode-icons解决， 生成注释格式 docstring，由Nils Werner开发的autoDocstring， 画图: Plantuml，Graphviz，Drawio Plantuml我主要用来绘制流程图，时序图，非常强大，这两种图用代码描述起来直观方便，有时也能替代一些思考过程。 Drawio绘制一些复杂的图，像一些教材上的那种展示图，比如《深入理解Linux内核》中那些数据结构的图片，用Plantuml就难以绘制。但使用Drawio加上自带手绘风格，比较漂亮，对标Visio Graphviz一般是在代码中自动生成的的，展示一些数据流，Profile结果什么的，基本上不会去手动写。 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-28 17:01:59 "},"other/快速搭建http服务.html":{"url":"other/快速搭建http服务.html","title":"快速搭建http服务","keywords":"","body":"快速搭建http服务 [TOC] 方法1： python自带服务 python2 python3 方法2：jupyter notebook 方法3：nodejs的http-server 有时想要通过浏览器来浏览linux上的相关文件，此时可以在linux上运行http服务。 方法1： python自带服务 python2 可以通过如下命令快速启动一个简单的http服务： python -m SimpleHTTPServer port 注：SimpleHTTPServer是linux机器上python2自带的一个WEB服务器，不需要自己安装。 python3 python -m http.server 8000 方法2：jupyter notebook 使用python安装jupyter，然后启动notebook服务。 方法3：nodejs的http-server 首先需要在linux上安装nodejs，如果是非root用户，可以下载二进制包，然后把对应的bin目录添加到PATH变量中。（不将其加入PATH变量，直接运行可能会出错） 然后安装 http-server ： npm install -g http-server 启动http服务： http-server -p 8000 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-18 19:31:30 "},"other/谷歌浏览器.html":{"url":"other/谷歌浏览器.html","title":"谷歌浏览器","keywords":"","body":"谷歌浏览器 [TOC] 开发工具主要有八个选项： 元素 资源 网络 源 时间表 简介 审核 控制台 在开发过程中记录诊断信息。如 console.log() 或 console.profile()。 一个可与文档和工具交互的 shell 提示符。 可以使用Ctrl+[和 Ctrl+] 快捷键在面板之间移动。 Ctrl+o 可以进入 Sources 面板并且提供一个列出所有可检查文件的搜索框。 Ctrl+Shift+o：打开一个对应函数/特定选择器的一个选择框，输入名称，跳到相应文件的相应行。 对于具体的文件，可以按Ctrl+f 快捷键，对文件中的内容进行搜索（搜索框在显示文件的最下方）。 Ctrl+Shift+f：对所有文件的内容进行搜索。会在最下方弹出一个搜索框。同时提供了正则表达式和敏感大小写的搜索方式，可能需要点击搜索框前面的符号开启。 JavaScript 可以直接在 Sources 面板中进行编辑。 对于css，在Element中点击相应的节点，在右边就会出现可以编辑的css格式 自定义 JavaScript 片段：有时候你想能够保存小的脚本，书签和实用的工具好让这些工具可以让你在调试的时候可以用的上。Snippets 是一个新的可以在这个开发流程中使用的开发者工具，它允许你在源面板中创建，存储和执行 JavaScript。在Sources左边一栏。 以下是 Snippets 比较有用的情况： 书签 所有你的书签可以作为片段进行存储，特别是那些你可能想编辑的。 实用工具 调试工具可以和当前页面进行交互，并且可以保存和调试。一个社区企划的列表已经被提供。 Debugging Snippets 提供了一个语法高亮显示并且可持续的多行控制台，这样使得调试代码比单行要更加便捷。 Monkey-patching code 你想要在运行时修复的代码可以通过 Snipptes 来完成，尽管多数时候你可能只是在源面板中实时编辑代码。 要打开抽屉式控制台（就是现实在其他工具栏的下方），你需要在键盘上按下 Esc 键或者点击开发者工具窗口右上角的 Show Drawer 按钮。 要清除控制台历史信息，你需要这么做： shell 提示符中输入 clear() 命令行 API。 在 Javascript 中执行 console.clear() 调用控制台 API。 使用键盘快捷键Ctrl + L console输出： console.log() console.warn() console.error() console.assert()方法仅仅只当它的第一个参数为 false 时才显示一个错误信息字符串（它的第二个参数） 一个简单的断言并且如何展示的例子。 console.assert(list.childNodes.length 500\"); ALL 显示所有控制台输出 Errors 只显示 console.error() 输出的信息 Warnings 只显示 console.warn() 输出的信息 Info 只显示 console.info() 输出的信息 Logs 只显示 console.log() 输出的信息 Debug 只显示 console.timeEnd() 和 console.debug() 输出的信息 选择元素： $()：返回第一个匹配 CSS 选择器的元素。这也是 document.quertSelector() 的快捷方式。 $$()：返回包含所有匹配 CSS 选择器的一个数组。这是 document.querySelectorAll() 的一个别名。 $x()：返回一个匹配特定 XPath 的数组。 Shitf+Enter 允许你从控制台进入多行模式。 格式化 JavaScript，开发者工具支持格式化精简后的 JavaScript 以便阅读。要格式化，你需要： 进入 Sources 面板，然后从脚本列表中选择你想要格式化脚本。 然后点击在开发者工具底部的格式化按钮(用大括号来标记) 你的代码应该已经排版好了 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-17 09:15:38 "},"windows/windows配置.html":{"url":"windows/windows配置.html","title":"windows配置","keywords":"","body":"windows配置 [TOC] 编程环境 相关软件 git github subline vs code PyCharm anaconda explorer预览py文件 配置windows的相关环境，安装相关软件。 编程环境 C与C++ dev c++ python（？Anaconda） PyCharm Node.js java myeclipse 命令行cmd，是否有优化版本，比如pycharm中的cmd ？power shell： https://sspai.com/post/52868 https://www.yiibai.com/powershell/ windows terminal：整合cmd、power shell。 相关软件 office 三件套 subline，VS code Adobe Acrobat DC：操作pdf everything：搜索文件 Beyond Compare：比较文件异同 Xshell+Xftp：操作远程服务器 Typora：编辑markdown文件 Oracle VM VirtualBox 或 VMware：虚拟机 git 和 Github Desktop git图形化管理工具：SourceTree，TortoiseGit 7-Zip：压缩文件，使用tar.gz格式 git 参考网站： git官网中文教程：https://git-scm.com/book/zh/v2 git线上实验：http://try.github.io/ github线上文档：https://help.github.com/cn/github github线上实验：https://lab.github.com/ github视频：https://www.youtube.com/user/GitHubGuides/playlists gitlab用户文档：https://docs.gitlab.com/ee/user/index.html 下载最新版本的git，然后配置： git config --global user.name \"appwhy\" git config --global user.email \"appwhy@qq.com\" # 在 Git 中缓存 GitHub 密码 git config --global credential.helper wincred git config --global color.ui true #语法高亮，显示加颜色 git config --list #查看全局配置 配置ssh秘钥： # 打开git bash，生成秘钥。 ssh-keygen -t rsa -b 4096 -C \"appwhy@qq.com\" ssh-keygen -t rsa -b 4096 -C \"appwhy@qq.com\" -f gitlab_rsa # -f 指定输出文件 github 常用快捷键： | 键盘快捷键 | 描述 | | :--------: | -------------- | | ? | 列出可用于该页面的键盘快捷键 | | 站点快捷键 | | | s 或 / | 聚焦于搜索栏。 | | esc | 退出聚焦 | | 仓库 | | | g d | 转到github.com(dashboard) | | g c | 转到 Code（代码） 选项卡 | | g i | 转到 Issues（议题） 选项卡。 | | g p | 转到 Pull requests（拉取请求） 选项卡。 | | 源代码编辑 | | | alt g | 跳至行 | | control f | 开始在文件编辑器中搜索 | | 源代码浏览 | | | t | 激活文件查找器 | | b | 打开追溯视图（blame view）。 | | y | 将 URL 展开为其规范形式。 | subline 参考： 完全介绍：https://www.w3cschool.cn/sublimetext/4qo5cozt.html 不同代码运行环境配置：https://zhuanlan.zhihu.com/p/35669986 官网：http://www.sublimetext.com/ 官网文档：http://www.sublimetext.com/docs/3/ 通用（General） Alt：调出菜单 Ctrl + Shift + P：调出命令板（Command Palette） Ctrl + `：调出控制台 编辑（Editing） Ctrl + Enter：在当前行下面新增一行然后跳至该行。 Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行。 Ctrl + ←/→：进行逐词移动 Ctrl + Shift + ←/→进行逐词选择 Ctrl + ↑/↓移动当前显示区域，不会改变文件。 Ctrl + Shift + ↑/↓移动当前行 选择（Selecting） Ctrl + D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + U进行回退，使用Esc退出多重编辑。会在每个词后出现光标。 Ctrl + Shift + L：在选中的多行后插入光标。 Ctrl + J：把当前选中区域合并为一行，以空格分隔。 Ctrl + M：在起始括号和结尾括号间切换 Ctrl + Shift + M：快速选择括号间的内容 Ctrl + Shift + J：快速选择同缩进的内容 Ctrl + Shift + Space：快速选择当前作用域（Scope）的内容 查找&替换（Finding&Replacing） F3：跳至当前关键字下一个位置 Shift + F3：跳到当前关键字上一个位置 Alt + F3：选中当前关键字出现的所有位置 Ctrl + F/H：进行标准查找/替换，之后： Ctrl + Shift + F：多文件搜索&替换 跳转（Jumping） Ctrl + P：跳转到指定文件，输入文件名后可以： @ 符号跳转：输入@symbol跳转到symbol符号所在的位置 #关键字跳转：输入#keyword跳转到keyword所在的位置 : 行号跳转：输入:12跳转到文件的第12行。 Ctrl + R：跳转到指定符号 Ctrl + G：跳转到指定行号 窗口（Window） Ctrl + Shift + N：创建一个新窗口 Ctrl + N：在当前窗口创建一个新标签 Ctrl + W：关闭当前标签，当窗口内没有标签时会关闭该窗口 Ctrl + Shift + T：恢复刚刚关闭的标签 屏幕（Screen） F11：切换普通全屏 Shift + F11：切换无干扰全屏 Alt + Shift + 2：进行左右分屏 Alt + Shift + 8：进行上下分屏 Alt + Shift + 5：进行上下左右分屏 分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏 vs code 参考： https://www.w3cschool.cn/visualstudiocode/visualstudiocode-iy3422zb.html https://segmentfault.com/a/1190000017949680 官方文档：https://code.visualstudio.com/docs/?dv=win 中文翻译（差）：https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/ VS Code 的定位是编辑器，而非IDE。但 VS Code 又比一般的编辑器的功能要丰富许多。 VS Code 自带了 TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。 命令面板是vscode快捷键的主要交互界面，可以使用f1或者Ctrl+Shift+P打开。 在 Ctrl+P 窗口下还可以: 直接输入文件名，跳转到文件 ? 列出当前可执行的动作 ! 显示 Errors或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @ 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入 # 根据名字查找 symbol，也可以 Ctrl+T 常用快捷键： Ctrl+Home ： 光标移到文件开头 Ctrl+End：光标移到文件结尾。 Ctrl+Shift+K：删除当前行。 Ctrl + Enter：在当前行下面新增一行然后跳至该行。 Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行。 Alt+↑↓：将当前行向上/下移动。 Ctrl+U：光标退回上一个位置。 Alt + Shift + I：在选中的文本的每一行的末尾都创建一个光标。 多光标：按住Alt键，然后在页面中希望中现光标的位置点击鼠标。 选中某个文本，然后反复按快捷键Ctrl + D， 即可将全文中与光标当前所在位置的词相同的词逐一加入选择。 PyCharm 参考： https://www.jianshu.com/p/2bfc19e1381c https://www.yiibai.com/pycharm/ settings/ Editor/ Font：调整编辑器的字体、大小等。 Color Schema：设置编辑文件时的背景颜色。 Console Font：调整控制台的字体、大小 Code Style/ Python：设置 tab size为4，使用4个空格代替Tab键。 File Encoding：调整文件编码，有3个地方，都设置为utf-8。 File and Code Templates：用于设置模板文件，便于省略部分代码的编写。 定位 Search Everywhere（双击Shift）：可以搜文件名、目录名(后面加/)、类名、方法名、函数名。 Ctrl+光标 当按住Ctrl，鼠标移到标识符上面时，会显示一些信息。 当按住Ctrl，并点击时，可以跳到定义处。快捷键Ctrl+B也有该作用。 当在定义处按住Ctrl，并点击时，会弹框列出所有引用的地方，只有一个地方引用时，会直接跳转。 最近打开的文件（Ctrl+E）：弹出一个提示框，显示最近打开的文件。Ctrl+Tab好像也有这个功能。 目录树的“雷达”：会将目录树定位到当前文件（正在编辑的那个文件）。 查找 Ctrl+F：当前文件查找 Ctrl+Q：查找当前方法的注释信息。 Ctrl+Shift+A：搜索IDE的功能，比如想看看这个文件的历史，就键入history 可以找到 Local history。Help -> Find Action Ctrl+P：调用方法时查看参数，在括号内按下，就知道当前位置该给啥参数。 Ctrl+Shift+F：全局查找，可以分别在项目内、模块内、目录内查找。 目录树某个目录右键，Find in Path，可以只在这个目录范围内进行查找 补全 Tab 万能的Alt+Enter：不同场景有不同的动作。 比如当在一个未找到引用的变量按下Alt+enter时，会弹窗，让你选择自动import、创建函数参数、重命名到一个已有的变量等。 在还没import（install）模块名时，自动添加import（install）相对应的模块。 在方法名上使用补注释。 在测试中使用帮你补充断言代码。 Surroud with（Ctrl+Alt+T）：快速将若干行代码包裹起来，如 try... except...。 Emmet：使用特定的语法来展开小段代码，它类似CSS选择器，使其成为完整的HTML代码。在编写完成后按Tab键就能进行展开。 编辑 Basic Ctrl+C(复制)。在没选择范围的情况下会复制当前行，而不需要先选择整行再复制。 Ctrl+V(粘贴)。Ctrl+Shift+V可以在剪贴板历史中选择一个去粘贴。 Ctrl+X(剪切) Ctrl+S(保存) Ctrl+Z(撤销)。Ctrl+Shift+Z反撤销。 Ctrl+/(注释)。注释后光标会自动到下一行，方便注释多行。 Ctrl+D(复制当前行) Ctrl+Shift+U(转换大小写) Ctrl+Alt+L(格式化) Ctrl+Alt+O(优化import) Shift+Alt+↑↓(上下移动行)、Shift+Ctrl+↑↓（上下移动语句。一个语句可能有多行。并且会决定要不要进块内和出块外）。简单的说，一个是物理移动行，一个是逻辑移动语句。 Shift+enter(在下面新开一行)。Ctrl+Alt+Enter在上面新开一行。 Shift+←→左右移动带选择。Ctr+←→单词级别的移动。 Ctrl+Shift+←→左右移动单词带选择。 Ctrl+[]，光标移动到块首/块尾。Ctrl+Shift+[]，光标移动到块首/块尾，并带有选择功能。 Alt+↑↓：光标移动到上一个方法/下一个方法。 Alt+←→：切换文件。 Ctrl+L(Find/ Move to next Occurrence) Extend Selection/ Shrink Selection（Ctrl+W / Ctrl+Shift+W）：用来选中单词、两个引号或括号之间的内容。而不是用鼠标费劲的去选。 多光标 Alt+点击：在不同地方执行该命令，可得到多个光标。按ESC可以取消光标。 Alt+鼠标拖动：选择多行，并在每行都有光标。按ESC可以取消光标。注意最开始的光标。 Ctrl+G：跳到第几行几列，用冒号隔开 重构 Rename：将一个变量rename,右键单击，选择Refactor->Rename，所有用到这个变量的地方都自动跟着变。 Safe delete：删除一个文件，如果该文件被其他文件所引用，就会给出提示，让其谨慎删除操作。 Extract（Ctrl+Alt+M）：提取选中的代码块生成一个新的变量、属性、方法、参数等 调优 Help->Edit Custom VM Options，配置多点内存，使流畅。 禁用掉没用的插件。 颜值：装插件Material Theme UI。好看很多。 其它 在配对符号'\")]}的关闭符号前，按相同按键，会忽略并移动光标到后面，不用老远的去按→方向键。 Smart Keys(Settings->Editor->General->Smart Keys设置) 输入单个字符时插入一对引号或括号。 当选中的时候输入引号或括号，在两边加上引号或括号，而不替换选择的内容。 换行时智能缩进 在语句内换行时会自动拼上反斜杠\\ 定义方法时自动插入self ？贤者模式(免打扰模式进行编码) New Scratch File： 临时编辑文件时用。 Copy Reference：比如在某个函数右键Copy Reference，粘贴到shell里面方便import。 静态分析。比如找出重复代码、检查代码是否符合pep8等。在左侧目录树上单击右键，选择“Inspect Code”。 在目录树新建文件的时候，可以多层，连目录一起创建。类似mkdir -p的效果。比如输入foo/bar/baz.py，如果没有目录foo和bar，会自动创建。 在编辑器内选择后，可以右键“search with google”、“execute selected in console” ？编辑代码的时候，行号右边会有标记，插入、删除、修改是不同标记，可点击进行diff和rollback 在目录树右键->Local History，可显示改动历史，并可还原到某个历史。(注：跟git没关系) 变量或表达式的最后键入.(点)，会出现提示，看最下面的部分有各种代码模板，例如现有变量a，在下一行键入 a.print 然后键入Tab，代码会变成print(a)，还有if,else等各种常用的代码模板。 Help->Tip of the Day：显示各种快捷操作。 anaconda anaconda组件解释： Anaconda Navigator是一个桌面图形用户界面（GUI），无需使用命令行即可启动应用程序并轻松管理conda程序包，环境和通道（？类似软件源）。Navigator可以在Anaconda Cloud或本地Anaconda存储库中搜索软件包。 conda：命令行程序conda既是程序包管理器又是环境管理器。pip只是一个程序包管理器。 Conda包是二进制文件，Pip安装包为wheels或源代码。 Pip安装Python包，而conda安装包可能包含用任何语言编写的软件的包。 Spyder是一个IDE，和其他的Python开发环境相比，它最大的优点就是模仿MATLAB的“工作空间”的功能，可以很方便地观察和修改数组的值。 jupyter qtconsole，可以看做是ipython的加强版，能够在shell里直接显示绘图结果。 conda创建虚拟环境： conda create --name venv36 python=3.6 # 创建一个名为venv36的虚拟环境 conda activate venv36 # 激活环境 conda deactivate # 退出虚拟环境 conda info --envs # 列出所有环境 conda env list explorer预览py文件 win10 文件夹预览文件功能开启：点击 [文件, 主页, 共享, 查看] 中的“查看”选项，在出现的选择中最左边有“预览窗格”选项。 打开注册表编辑器（registry editor）：Win+R 键入 regedit 打开注册表。 找到 \\HKEY_CLASSES_ROOT\\.py 项， 如果没有自行创建。 对.py 项增加如下键值对： | 名称 | 类型 | 数据 | | :-----------: | :----: | :-------------------------: | | (默认) | REG_SZ | Python.File 或 py_auto_file | | Content Type | REG_SZ | plain/text | | PerceivedType | REG_SZ | text | 关闭注册表，此时就能预览py文件了。对其他文件同意有效 Copyright @appwhy all right reserved，powered by Gitbook文件更新于： 2020-06-28 21:17:40 "}}